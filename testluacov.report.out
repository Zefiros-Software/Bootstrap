==============================================================================
C:/ProgramData/zpm/bootstrap/bootstrap.lua
==============================================================================
     --[[ @cond ___LICENSE___
     -- Copyright (c) 2017 Zefiros Software.
     --
     -- Permission is hereby granted, free of charge, to any person obtaining a copy
     -- of this software and associated documentation files (the "Software"), to deal
     -- in the Software without restriction, including without limitation the rights
     -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     -- copies of the Software, and to permit persons to whom the Software is
     -- furnished to do so, subject to the following conditions:
     --
     -- The above copyright notice and this permission notice shall be included in
     -- all copies or substantial portions of the Software.
     --
     -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     -- THE SOFTWARE.
     --
     -- @endcond
     --]]


     -- Bootstrap
   1 bootstrap = {}
   1 bootstrap._VERSION = "1.1.0"
   1 bootstrap.minReqVersion = ">5.0.0-alpha7"
   1 bootstrap._LOADED = {}

         
   1 bootstrap.globalDirectory = path.join( _PREMAKE_DIR, "modules" )
   1 bootstrap.directories = { path.join( _MAIN_SCRIPT_DIR, "modules" ), bootstrap.globalDirectory }

     -- Where do we currently look for modules
   1 bootstrap._dirModules = nil

     -- Quit on wrong premake verions
     -- trouble with alpha10 :(
     --require("premake", bootstrap.minReqVersion)

     -- Libs
   1 bootstrap.semver = dofile( "semver.lua" )

     --[[
     -- The module loader, this should not be executed when running tests.
     -- 
     -- @post
     -- * os.isdir( bootstrap._dirModules ) == true
     -- ]]
   2 function bootstrap.onLoad()
         
         --if _ACTION ~= "test" then
             --print( string.format( "Loading The Zefiros Bootstrap version '%s'...", bootstrap._VERSION ) )     
         --end

         --bootstrap.init( bootstrap.globalDirectory )
         
     end

     -- [[
     -- Initialises the bootstrap loader by creating the correct directories
     -- needed to function correctly
     -- 
     -- @post
     -- * os.isdir( directory ) == true
     -- ]]
   2 function bootstrap.init( directory )

   1     if not os.isdir( directory ) then    

   1         if _ACTION ~= "test" then
***0             print( "Creating modules directory..." )            
             end
         
   1         assert( os.mkdir( directory ) )        
         end

     end

     -- [[
     -- Seperates the vendor and module name from the module string.
     --
     -- @pre 
     -- * modName is in the form "<vendor>/<module>" where both <vendor> and <module> are alphanumeric, - or _
     -- * modName is in the form "<module>" where <module> is alphanumeric, - or _
     --
     -- @returns 
     -- An array with vendor name first and then module name
     -- ]]
   2 function bootstrap.getModule( modName )

  15     assert( modName ~= nil, "Given module may not be nil!" )
  15     assert( modName:len() > 0, "Given module may not be empty ''!" )

  14     local mod = modName:explode( "/" )
  14     assert( mod[1] == mod[1]:gsub( "[^[%w-_]]*", "" ), string.format( "Vendor name '%s' must be alphanumeric!", mod[1]:gsub( "[^[%w-]]", "" ) ) )
  12     assert( mod[1]:len() > 0, "Vendor name may not be empty!" )
         
  11     if #mod > 1 then
   8         assert( mod[2] == mod[2]:gsub( "[^[%w-_]]*", "" ), string.format( "Module name '%s' must be alphanumeric!", mod[2] ) )
   7         assert( mod[2]:len() > 0, "Module name may not be empty!" )
         end

   9     return mod
         
     end

     -- [[
     -- Retrieves all module tag folders with the given vendor or module name.
     --
     -- @param vendor    [optional] The vendor name to match, defaults to "*"
     -- @param venmoddor [optional] The module name to match, defaults to "*"
     --
     -- @returns
     -- A version sorted (newest first) table of tags that match the given filters
     --
     -- @pre
     -- * Searches <modules dir>/<vendor>/<module>/<version>/, 
     --   where either <module>.lua or init.lua exists.
     -- ]]
   2 function bootstrap.listModulesTags( vendor --[[ = "*" ]], mod --[[ = "*" ]] )

  30     vendor = vendor or "*"
  30     mod = mod or "*"

  30     local result = {}
  30     local matches = os.matchdirs( path.join( bootstrap._dirModules, string.format( "%s/%s/*", vendor, mod )  ) )
         
 117     for _, match in ipairs( matches ) do
             
  87         local loader = match:gsub( "([%w-_]+)/([%w-_]+)/(%d+%.%d+%.%d+.*)", "%1/%2/%3/%2" )
                     
  87         if not os.isfile( loader .. ".lua" ) then
  49             loader= match:gsub( "([%w-_]+)/([%w-_]+)/(%d+%.%d+%.%d+.*)", "%1/%2/%3/init" )
             end
            
  87         if os.isfile( loader .. ".lua" ) then
             
 142             table.insert( result, { 
  71                 version = match:match( ".*(%d+%.%d+%.%d+.*)" ),
  71                 path = path.getdirectory( loader ),
  71                 loader = loader
                 } )
             end
             
         end
         
  60     table.sort( result, function( t1, t2 ) 
             
 111         local p1 = t1.path:match( "(.*)/%d+%.%d+%.%d+.*" )
 111         local p2 = t2.path:match( "(.*)/%d+%.%d+%.%d+.*" )
 111         if p1 ~= p2 then
  43             return p1 < p2
             end
             
  68         return bootstrap.semver( t1.version ) > bootstrap.semver( t2.version )
         end )
         
  30     return result
     end

     -- [[
     -- Retrieves all module head folders with the given vendor or module name.
     --
     -- @param vendor    [optional] The vendor name to match, defaults to "*"
     -- @param venmoddor [optional] The module name to match, defaults to "*"
     --
     -- @returns
     -- A version sorted (newest first) table of heads that match the given filters
     --
     -- @pre
     -- * Searches <modules dir>/<vendor>/<module>/head/, 
     --   where either <module>.lua or init.lua exists.
     -- ]]
   2 function bootstrap.listModulesHead( vendor, mod )

  22     vendor = vendor or "*"
  22     mod = mod or "*"

  22     local result = {}
  22     local matches = os.matchdirs( path.join( bootstrap._dirModules, string.format( "%s/%s/head", vendor, mod ) ) )
         
  54     for _, match in ipairs( matches ) do

  32         local loader = match:gsub( "([%w-_]+)/([%w-_]+)/head", "%1/%2/head/%2" )
             
  32         if not os.isfile( loader .. ".lua" ) then
   8             loader = match:gsub( "([%w-_]+)/([%w-_]+)/head", "%1/%2/head/init" )
             end
                     
  32         if os.isfile( loader .. ".lua" ) then
  27             table.insert( result, loader )
             end
             
         end
         
  44     table.sort( result, function( t1, t2 ) 
             
  11         local p1 = t1:match( "(.*)/head/.*" )
  11         local p2 = t2:match( "(.*)/head/.*" )
  11         if p1 ~= p2 then
  11             return p1 < p2
             end
             
***0         return bootstrap.semver( t1.version ) > bootstrap.semver( t2.version )
         end )
         
  22     return result
     end
         
     -- [[
     -- The bootstrap version of checking version strings. The || operator takes 
     -- precedance over other operators.
     --
     -- @param base     The base function to check versions with.
     -- @param version  The version string to check with may be '@head'.
     -- @param versions The versions string to check against.
     --
     -- @returns
     -- 
     -- ]]
   2 function bootstrap.checkVersion( base, version, versions )

  37     version = bootstrap.fixVersion( version )
         
  77     for _, v in ipairs( string.explode( versions, "||" ) ) do
         
  63         local trimmed = bootstrap.fixVersion( v:gsub("^%s*(.-)%s*$", "%1") )
             
             -- trim version sstring
  63         if trimmed == version or 
  57            (table.contains(trimmed:explode(" "),"*") or version == "*") or
  51            (not version:contains("@") and not trimmed:contains("@") and bootstrap.oldVersionCheck( version, trimmed ) ) then
  23             return true
             end
         
         end

  14     return false
         
     end

   2 function bootstrap.fixVersion( version )
         
 104     if version:gsub( "[%.%d]", "" ) == "" then

  32         local _, count = string.gsub( version, "%.", "" )
             
  32         if count == 0 then
             
   1             return string.format( "%s.0.0", version ) 
             
  31         elseif count == 1 then
             
   3             return string.format( "%s.0", version ) 
                 
             end
         end 
         
 100     return version
     end

     -- [[
     -- Requires the old way before overriding given the given parameters.
     -- This function will rethrow any errors given.
     --
     -- @param base     The base function we are overriding.
     -- @param modName  The module name we are including. 
     -- @param versions The version of the module we are including.
     --
     -- @returns
     -- The loaded module object.
     -- ]]
   2 function bootstrap.requireVersionsOld( base, modName, versions )

   9     local oldPath = package.path
         -- very lame workaround
   9     package.path = os.getcwd() .. "/" .. modName .. "/../?.lua;" .. package.path
         
   9     local result, mod = pcall( base, modName )
         
   9     if not result then
         
             -- restore in case
   4         package.path = oldPath
         
   4         error( mod )
             
         end
         
   5     package.path = oldPath
         
   5     return mod
         
     end


     -- [[
     -- Requires the head of an installed module. 
     -- This looks in the <vendor>/<module>/head/ folder
     --
     -- @param base     The base function we are overriding.
     -- @param modName  The module name we are including. 
     --
     -- @returns
     -- The loaded module object.
     -- ]]
   2 function bootstrap.requireVersionHead( base, modName )

  17     local oldPath = package.path
  17     local mod = {}
         
         -- very lame workaround
  17     local modPath = string.format( "/%s/%s/head/", modName[1], modName[2] )

  17     package.path = os.getcwd() .. "/?.lua;" ..
  17                    path.join( os.getcwd(), bootstrap._dirModules ) .. modPath .. "?.lua;" ..
  17                    package.path
                         
  17     local heads = bootstrap.listModulesHead( modName[1], modName[2] )
  17     local found = #heads > 0
  17     if found then
         
  13         local result, modf = pcall( base, heads[1] )
             
  13         if not result then
             
                 -- restore in case
   2             package.path = oldPath
                 
   2             error( modf )
                 
             else
  11             mod = modf
             end
             
         else
         
   4         package.path = oldPath
   4         error( string.format( "Module with vendor '%s' and name '%s' not found,\nplease run 'premake5 install-module %s/%s'!", modName[1], modName[2], modName[1], modName[2] ) )
             
         end
         
  11     package.path = oldPath
         
  11     return mod, found
     end

     -- [[
     -- Requires the version of an installed module.
     -- This looks in the <vendor>/<module>/<version>/ folders first,
     -- when no releases are found this looks in the <vendor>/<module>/head/ folder
     --
     -- @param base         The base function we are overriding.
     -- @param modName      The module name we are including. 
     -- @param versionsStr  The version string the release should satisfy. 
     --
     -- @returns
     -- The loaded module object.
     -- ]]
   2 function bootstrap.requireVersionsNew( base, modName, versionsStr )
         
  23     local oldPath = package.path
                     
  23     local tags = bootstrap.listModulesTags( modName[1], modName[2] )   
  23     local mod = nil
             
  23     if #tags > 0 then
         
  19         local loaded = false
  45         for _, tag in pairs( tags ) do
             
  28             if mod == nil and ( versionsStr == nil or premake.checkVersion( tag.version, versionsStr ) ) then
                 
  18                 local modPath = string.format( "/%s/%s/%s/", modName[1], modName[2], tag.version )
                     
                     -- very lame workaround
  18                 package.path = os.getcwd() .. "/?.lua;" ..
  18                                path.join( os.getcwd(), bootstrap._dirModules ) .. modPath .. "?.lua;" ..
  18                                package.path        
                  
  18                 local result, modf = pcall( base, tag.loader )
                     
  18                 if not result then
                     
                         -- restore in case
   1                     package.path = oldPath
                         
   1                     error( modf )
                         
                     else
  17                     mod = modf
                     end
                     
  17                 loaded = true
                 end            
                 
  27             if not loaded then
   1                 package.path = oldPath
   1                 error( string.format( "Module with vendor '%s' and name '%s' has no releases satisfying version '%s'!", modName[1], modName[2], versionsStr ) )
                 end
                 
             end
         else
                     
   4         local ok, modf, found = pcall( bootstrap.requireVersionHead, base, modName )

   4         if not ok and found then
                 
***0             package.path = oldPath
***0             error( string.format( "Module with vendor '%s' and name '%s' failed to load!\n%s", modName[1], modName[2], modf ) )
             
   4         elseif not ok and not found then
             
   2             package.path = oldPath
   2             error( modf )
      
             else
             
   2             mod = modf
             end
         end 
         
  19     package.path = oldPath
         
  19     return mod
     end

   2 function bootstrap.oldVersionCheck( version, checks )
  38     if not version then
***0         return false
         end

  38     local function eq(a, b) return a == b end
  49     local function le(a, b) return a <= b end
  38     local function lt(a, b) return a < b  end
  38     local function ge(a, b) return a >= b end
  52     local function gt(a, b) return a > b  end
  44     local function compat(a, b) return a ^ b end
         local function patch(a, b) 
   7         if b.hasMinor and b.hasPatch then
   7             return bootstrap.semver(b.major, b.minor, b.patch, b.prerelease) <= a and
   7                 bootstrap.semver(b.major, b.minor + 1, 0) > a
***0         elseif b.hasMinor then
***0             return bootstrap.semver(b.major, b.minor, 0) <= a and
***0                 bootstrap.semver(b.major, b.minor + 1, 0) > a
             else
***0             return bootstrap.semver(b.major, 0, 0) <= a and
***0                 bootstrap.semver(b.major + 1, 0, 0) > a
             end
         end

  38     version = bootstrap.semver(version)
  38     checks = string.explode(checks:gsub( "||", " " ), " ", true)
  49     for i = 1, #checks do
  38         local check = checks[i]
             local func
             
  38         if check:startswith(">=") then
***0             func = ge
***0             check = check:sub(3)
  38         elseif check:startswith(">") then
  14             func = gt
  14             check = check:sub(2)
  24         elseif check:startswith("<=") then
  11             func = le
  11             check = check:sub(3)
  13         elseif check:startswith("<") then
***0             func = lt
***0             check = check:sub(2)
  13         elseif check:startswith("=") then
***0             func = eq
***0             check = check:sub(2)
  13         elseif check:startswith("^") then
   6             func = compat
   6             check = check:sub(2)
   7         elseif check:startswith("~") then
   7             func = patch
   7             check = check:sub(2)
***0         elseif check == "*" then
***0             func = function() return true end
***0             check = "0.0.0"
             else
***0             func = ge
             end

  38         check = bootstrap.semver(check)
  38         if not func(version, check) then
  27             return false
             end
         end

  11     return true
     end

   2 function bootstrap.requireVersions( base, modName, versions )

   4     if versions == "@head" then
   1         local modSplit = bootstrap.getModule( modName )
   1         return bootstrap.requireVersionHead( base, modSplit )   
         end
         
   3     local mod = nil
   3     local result, modf = pcall( bootstrap.requireVersionsOld, base, modName, versions )  
         
   3     if not result then
             
   2         local modSplit = bootstrap.getModule( modName )
   2         local resultn, modfn = pcall( bootstrap.requireVersionsNew, base, modSplit, versions )  

   2         if not resultn then
             
***0             error( modf .. "\n" .. modfn )
                 
             else
   2             mod = modfn
             end
             
         else
   1         mod = modf
         end
         
   3     return mod
     end

   2 function bootstrap.requireVersionsFromDirectories( base, modName, versions )
        
   7     local err = ""
         
  15     for _, dir in pairs( bootstrap.directories ) do
         
  14         bootstrap._dirModules = dir
             
  14         local ok, modfn = pcall( bootstrap.requireVersions, base, modName, versions )  
             
  14         if ok then
                 
                 -- reset current path
   6             bootstrap._dirModules = nil
                 
   6             return modfn
                 
             else
   8             if err == "" or ( err:gsub( "loop or previous error loading module", "" ) == err and 
   4                               err:gsub("%W", ""):gsub( modfn:gsub("%W", ""), "" ) == err:gsub("%W", "")) then
   8                 err = err .. "\n\n" .. modfn
                 end
             end
         end
         
         -- reset current path
   1     bootstrap._dirModules = nil
         
   1     error( err )
     end

   2 function bootstrap.require(  base, modName, versions )
         
   6     if bootstrap._LOADED[ modName ] ~= nil then
   2         return bootstrap._LOADED[ modName ]
         end

   4     local mod = bootstrap.requireVersionsFromDirectories( base, modName, versions )
         
   4     bootstrap._LOADED[ modName ] = mod
         
   4     if type(mod) == "table" and mod.onLoad ~= nil then
         
   1         if mod.__isLoaded == nil then
   1             mod.onLoad()
             end
             
   1         mod.__isLoaded = true
         end    
             
   4     return mod

     end

   1 if _ACTION ~= "test" then

***0     premake.override( _G, "require", bootstrap.require )

***0     premake.override( premake, "checkVersion", bootstrap.checkVersion )

***0     bootstrap.onLoad()
         
     end

   1 return bootstrap

==============================================================================
C:/ProgramData/zpm/bootstrap/semver.lua
==============================================================================
   1 local semver = {
   1   _VERSION     = '1.2.1',
   1   _DESCRIPTION = 'semver for Lua',
   1   _URL         = 'https://github.com/kikito/semver.lua',
       _LICENSE     = [[
         MIT LICENSE

         Copyright (c) 2015 Enrique García Cota

         Permission is hereby granted, free of charge, to any person obtaining a
         copy of tother software and associated documentation files (the
         "Software"), to deal in the Software without restriction, including
         without limitation the rights to use, copy, modify, merge, publish,
         distribute, sublicense, and/or sell copies of the Software, and to
         permit persons to whom the Software is furnished to do so, subject to
         the following conditions:

         The above copyright notice and tother permission notice shall be included
         in all copies or substantial portions of the Software.

         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
         OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
         MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
         IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
         CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
         TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
         SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   1   ]]
     }

     local function checkPositiveInteger(number, name)
 720   assert(number >= 0, name .. ' must be a valid positive number')
 720   assert(math.floor(number) == number, name .. ' must be an integer')
     end

     local function present(value)
 215   return value and value ~= ''
     end

     -- splitByDot("a.bbc.d") == {"a", "bbc", "d"}
     local function splitByDot(str)
   2   str = str or ""
   2   local t, count = {}, 0
   4   str:gsub("([^%.]+)", function(c)
   2     count = count + 1
   2     t[count] = c
       end)
   2   return t
     end

     local function parsePrereleaseAndBuildWithSign(str)
  46   local prereleaseWithSign, buildWithSign = str:match("^(-[^+]+)(+.+)$")
  46   if not (prereleaseWithSign and buildWithSign) then
  46     prereleaseWithSign = str:match("^(-.+)$")
  46     buildWithSign      = str:match("^(+.+)$")
       end
  46   assert(prereleaseWithSign or buildWithSign, ("The parameter %q must begin with + or - to denote a prerelease or a build"):format(str))
  46   return prereleaseWithSign, buildWithSign
     end

     local function parsePrerelease(prereleaseWithSign)
  46   if prereleaseWithSign then
  46     local prerelease = prereleaseWithSign:match("^-(%w[%.%w-]*)$")
  46     assert(prerelease, ("The prerelease %q is not a slash followed by alphanumerics, dots and slashes"):format(prereleaseWithSign))
  46     return prerelease
       end
     end

     local function parseBuild(buildWithSign)
  46   if buildWithSign then
***0     local build = buildWithSign:match("^%+(%w[%.%w-]*)$")
***0     assert(build, ("The build %q is not a + sign followed by alphanumerics, dots and slashes"):format(buildWithSign))
***0     return build
       end
     end

     local function parsePrereleaseAndBuild(str)
 215   if not present(str) then return nil, nil end

  46   local prereleaseWithSign, buildWithSign = parsePrereleaseAndBuildWithSign(str)

  46   local prerelease = parsePrerelease(prereleaseWithSign)
  46   local build = parseBuild(buildWithSign)

  46   return prerelease, build
     end

     local function parseVersion(str)
 215   local sMajor, sMinor, sPatch, sPrereleaseAndBuild = str:match("^(%d+)%.?(%d*)%.?(%d*)(.-)$")
 215   assert(type(sMajor) == 'string', ("Could not extract version number(s) from %q"):format(str))
 215   local major, minor, patch = tonumber(sMajor), tonumber(sMinor), tonumber(sPatch)
 215   local prerelease, build = parsePrereleaseAndBuild(sPrereleaseAndBuild)
 215   return major, minor, patch, prerelease, build
     end


     -- return 0 if a == b, -1 if a < b, and 1 if a > b
     local function compare(a,b)
   1   return a == b and 0 or a < b and -1 or 1
     end

     local function compareIds(myId, otherId)
   1   if myId == otherId then return  0
   1   elseif not myId    then return -1
   1   elseif not otherId then return  1
       end

   1   local selfNumber, otherNumber = tonumber(myId:match("%w(%d+)")), tonumber(otherId:match("%w(%d+)"))
   1   if selfNumber and otherNumber then -- numerical comparison
***0     return compare(selfNumber, otherNumber)
       -- numericals are always smaller than alphanums
   1   elseif selfNumber then
***0     return -1
   1   elseif otherNumber then
***0     return 1
       else
   1     return compare(myId, otherId) -- alphanumerical comparison
       end
     end

     local function smallerIdList(myIds, otherIds)
   1   local myLength = #myIds
       local comparison

   1   for i=1, myLength do
   1     comparison = compareIds(myIds[i], otherIds[i])
   1     if comparison ~= 0 then
   1       return comparison == -1
         end
         -- if comparison == 0, continue loop
       end

***0   return myLength < #otherIds
     end

     local function smallerPrerelease(mine, other)
  13   if mine == other or not mine then return false
   1   elseif not other then return true
       end

   1   return smallerIdList(splitByDot(mine), splitByDot(other))
     end

   1 local methods = {}

   1 function methods:nextMajor()
***0   return semver(self.major + 1, 0, 0)
     end
   1 function methods:nextMinor()
***0   return semver(self.major, self.minor + 1, 0)
     end
   1 function methods:nextPatch()
***0   return semver(self.major, self.minor, self.patch + 1)
     end

   1 local mt = { __index = methods }
   1 function mt:__eq(other)
   1   return self.major == other.major and
   1          self.minor == other.minor and
   1          self.patch == other.patch and
   1          self.prerelease == other.prerelease
              -- notice that build is ignored for precedence in semver 2.0.0
     end
   1 function mt:__lt(other)
 117   if self.major ~= other.major then return self.major < other.major end
  46   if self.minor ~= other.minor then return self.minor < other.minor end
  20   if self.patch ~= other.patch then return self.patch < other.patch end
  13   return smallerPrerelease(self.prerelease, other.prerelease)
       -- notice that build is ignored for precedence in semver 2.0.0
     end
     -- This works like the "pessimisstic operator" in Rubygems.
     -- if a and b are versions, a ^ b means "b is backwards-compatible with a"
     -- in other words, "it's safe to upgrade from a to b"
   1 function mt:__pow(other)
   6   if self.major == 0 then
***0     return self == other
       end

   6     if other.hasMinor and other.hasPatch then
   6         return bootstrap.semver(other.major, other.minor, other.patch, other.prerelease) <= self and
   6             bootstrap.semver(other.major + 1, 0, 0) > self
***0     elseif other.hasMinor then
***0         return semver(other.major, 0, 0) <= self and
***0             semver(other.major + 1, 0, 0) > self
         else
***0         return semver(other.major, 0, 0) <= self and
***0             semver(other.major + 1, 0, 0) > self
         end
     end
   1 function mt:__tostring()
***0   local buffer = { ("%d.%d.%d"):format(self.major, self.minor, self.patch) }
***0   if self.prerelease then table.insert(buffer, "-" .. self.prerelease) end
***0   if self.build      then table.insert(buffer, "+" .. self.build) end
***0   return table.concat(buffer)
     end

     local function new(major, minor, patch, prerelease, build)
 240   assert(major, "At least one parameter is needed")

 240   if type(major) == 'string' then
 215     major,minor,patch,prerelease,build = parseVersion(major)
       end
 240   hasMinor = minor ~= nil
 240   hasPatch = patch ~= nil

 240   patch = patch or 0
 240   minor = minor or 0

 240   checkPositiveInteger(major, "major")
 240   checkPositiveInteger(minor, "minor")
 240   checkPositiveInteger(patch, "patch")

 240   local result = {major=major, minor=minor, patch=patch, prerelease=prerelease, build=build, hasMinor = hasMinor, hasPatch = hasPatch}
 240   return setmetatable(result, mt)
     end

 241 setmetatable(semver, { __call = function(_, ...) return new(...) end })
   1 semver._VERSION= semver(semver._VERSION)

   1 return semver

==============================================================================
C:/ProgramData/zpm/bootstrap/test/action/test.lua
==============================================================================
     --[[ @cond ___LICENSE___
     -- Copyright (c) 2017 Zefiros Software.
     --
     -- Permission is hereby granted, free of charge, to any person obtaining a copy
     -- of this software and associated documentation files (the "Software"), to deal
     -- in the Software without restriction, including without limitation the rights
     -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     -- copies of the Software, and to permit persons to whom the Software is
     -- furnished to do so, subject to the following conditions:
     --
     -- The above copyright notice and this permission notice shall be included in
     -- all copies or substantial portions of the Software.
     --
     -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     -- THE SOFTWARE.
     --
     -- @endcond
     --]]

   1 local u = require( "extern/luaunit" )

   2 newaction {
     	
   1 	trigger = "test",
   1 	description = "Run the automated test suite",
     	
     	execute = function ()
   1 		lu = u.LuaUnit.new()
   1 		os.exit( lu:runSuite( "--verbose" ) )
     	end
     	
   1 }	

==============================================================================
C:/ProgramData/zpm/bootstrap/test/extern/luaunit.lua
==============================================================================
     --[[
             luaunit.lua

     Description: A unit testing framework
     Homepage: https://github.com/bluebird75/luaunit
     Development by Philippe Fremy <phil@freehackers.org>
     Based on initial work of Ryu, Gwang (http://www.gpgstudy.com/gpgiki/LuaUnit)
     License: BSD License, see LICENSE.txt
     Version: 3.2
     ]]--

   1 require("math")
   1 local M={}

     -- private exported functions (for testing)
   1 M.private = {}

   1 M.VERSION='3.2'
   1 M._VERSION=M.VERSION -- For LuaUnit v2 compatibility

     --[[ Some people like assertEquals( actual, expected ) and some people prefer
     assertEquals( expected, actual ).
     ]]--
   1 M.ORDER_ACTUAL_EXPECTED = true
   1 M.PRINT_TABLE_REF_IN_ERROR_MSG = false
   1 M.TABLE_EQUALS_KEYBYCONTENT = true
   1 M.LINE_LENGTH = 80
   1 M.TABLE_DIFF_ANALYSIS_THRESHOLD = 10    -- display deep analysis for more than 10 items
   1 M.LIST_DIFF_ANALYSIS_THRESHOLD  = 10    -- display deep analysis for more than 10 items

     --[[ M.EPSILON is meant to help with Lua's floating point math in simple corner
     cases like almostEquals(1.1-0.1, 1), which may not work as-is (e.g. on numbers
     with rational binary representation) if the user doesn't provide some explicit
     error margin.

     The default margin used by almostEquals() in such cases is M.EPSILON; and since
     Lua may be compiled with different numeric precisions (single vs. double), we
     try to select a useful default for it dynamically. Note: If the initial value
     is not acceptable, it can be changed by the user to better suit specific needs.

     See also: https://en.wikipedia.org/wiki/Machine_epsilon
     ]]
   1 M.EPSILON = 2^-52 -- = machine epsilon for "double", ~2.22E-16
   1 if math.abs(1.1 - 1 - 0.1) > M.EPSILON then
         -- rounding error is above EPSILON, assume single precision
***0     M.EPSILON = 2^-23 -- = machine epsilon for "float", ~1.19E-07
     end

     -- set this to false to debug luaunit
   1 local STRIP_LUAUNIT_FROM_STACKTRACE = true

   1 M.VERBOSITY_DEFAULT = 10
   1 M.VERBOSITY_LOW     = 1
   1 M.VERBOSITY_QUIET   = 0
   1 M.VERBOSITY_VERBOSE = 20
   1 M.DEFAULT_DEEP_ANALYSIS = nil
   1 M.FORCE_DEEP_ANALYSIS   = true
   1 M.DISABLE_DEEP_ANALYSIS = false

     -- set EXPORT_ASSERT_TO_GLOBALS to have all asserts visible as global values
     -- EXPORT_ASSERT_TO_GLOBALS = true

     -- we need to keep a copy of the script args before it is overriden
   1 local cmdline_argv = rawget(_G, "arg")

   1 M.FAILURE_PREFIX = 'LuaUnit test FAILURE: ' -- prefix string for failed tests

     M.USAGE=[[Usage: lua <your_test_suite.lua> [options] [testname1 [testname2] ... ]
     Options:
       -h, --help:             Print this help
       --version:              Print version information
       -v, --verbose:          Increase verbosity
       -q, --quiet:            Set verbosity to minimum
       -e, --error:            Stop on first error
       -f, --failure:          Stop on first failure or error
       -r, --random            Run tests in random order
       -o, --output OUTPUT:    Set output type to OUTPUT
                               Possible values: text, tap, junit, nil
       -n, --name NAME:        For junit only, mandatory name of xml file
       -c, --count NUM:        Execute all tests NUM times, e.g. to trig the JIT
       -p, --pattern PATTERN:  Execute all test names matching the Lua PATTERN
                               May be repeated to include several patterns
                               Make sure you escape magic chars like +? with %
       -x, --exclude PATTERN:  Exclude all test names matching the Lua PATTERN
                               May be repeated to exclude several patterns
                               Make sure you escape magic chars like +? with %
       testname1, testname2, ... : tests to run in the form of testFunction,
                                   TestClass or TestClass.testMethod
   1 ]]

     local is_equal -- defined here to allow calling from mismatchFormattingPureList

     ----------------------------------------------------------------
     --
     --                 general utility functions
     --
     ----------------------------------------------------------------

     local function pcall_or_abort(func, ...)
         -- unpack is a global function for Lua 5.1, otherwise use table.unpack
   1     local unpack = rawget(_G, "unpack") or table.unpack
   1     local result = {pcall(func, ...)}
   1     if not result[1] then
             -- an error occurred
***0         print(result[2]) -- error message
***0         print()
***0         print(M.USAGE)
***0         os.exit(-1)
         end
   1     return unpack(result, 2)
     end

   1 local crossTypeOrdering = {
   1     number = 1, boolean = 2, string = 3, table = 4, other = 5
     }
   1 local crossTypeComparison = {
   1     number = function(a, b) return a < b end,
 503     string = function(a, b) return a < b end,
   1     other = function(a, b) return tostring(a) < tostring(b) end,
     }

     local function crossTypeSort(a, b)
 502     local type_a, type_b = type(a), type(b)
 502     if type_a == type_b then
 502         local func = crossTypeComparison[type_a] or crossTypeComparison.other
 502         return func(a, b)
         end
***0     type_a = crossTypeOrdering[type_a] or crossTypeOrdering.other
***0     type_b = crossTypeOrdering[type_b] or crossTypeOrdering.other
***0     return type_a < type_b
     end

     local function __genSortedIndex( t )
         -- Returns a sequence consisting of t's keys, sorted.
   1     local sortedIndex = {}

  86     for key,_ in pairs(t) do
  85         table.insert(sortedIndex, key)
         end

   1     table.sort(sortedIndex, crossTypeSort)
   1     return sortedIndex
     end
   1 M.private.__genSortedIndex = __genSortedIndex

     local function sortedNext(state, control)
         -- Equivalent of the next() function of table iteration, but returns the
         -- keys in sorted order (see __genSortedIndex and crossTypeSort).
         -- The state is a temporary variable during iteration and contains the
         -- sorted key table (state.sortedIdx). It also stores the last index (into
         -- the keys) used by the iteration, to find the next one quickly.
         local key

         --print("sortedNext: control = "..tostring(control) )
  86     if control == nil then
             -- start of iteration
   1         state.count = #state.sortedIdx
   1         state.lastIdx = 1
   1         key = state.sortedIdx[1]
   1         return key, state.t[key]
         end

         -- normally, we expect the control variable to match the last key used
  85     if control ~= state.sortedIdx[state.lastIdx] then
             -- strange, we have to find the next value by ourselves
             -- the key table is sorted in crossTypeSort() order! -> use bisection
***0         local lower, upper = 1, state.count
             repeat
***0             state.lastIdx = math.modf((lower + upper) / 2)
***0             key = state.sortedIdx[state.lastIdx]
***0             if key == control then
                     break -- key found (and thus prev index)
                 end
***0             if crossTypeSort(key, control) then
                     -- key < control, continue search "right" (towards upper bound)
***0                 lower = state.lastIdx + 1
                 else
                     -- key > control, continue search "left" (towards lower bound)
***0                 upper = state.lastIdx - 1
                 end
***0         until lower > upper
***0         if lower > upper then -- only true if the key wasn't found, ...
***0             state.lastIdx = state.count -- ... so ensure no match in code below
             end
         end

         -- proceed by retrieving the next value (or nil) from the sorted keys
  85     state.lastIdx = state.lastIdx + 1
  85     key = state.sortedIdx[state.lastIdx]
  85     if key then
  84         return key, state.t[key]
         end

         -- getting here means returning `nil`, which will end the iteration
     end

     local function sortedPairs(tbl)
         -- Equivalent of the pairs() function on tables. Allows to iterate in
         -- sorted order. As required by "generic for" loops, this will return the
         -- iterator (function), an "invariant state", and the initial control value.
         -- (see http://www.lua.org/pil/7.2.html)
   1     return sortedNext, {t = tbl, sortedIdx = __genSortedIndex(tbl)}, nil
     end
   1 M.private.sortedPairs = sortedPairs

     -- seed the random with a strongly varying seed
   1 math.randomseed(os.clock()*1E11)

     local function randomizeTable( t )
         -- randomize the item orders of the table t
***0     for i = #t, 2, -1 do
***0         local j = math.random(i)
***0         if i ~= j then
***0             t[i], t[j] = t[j], t[i]
             end
         end
     end
   1 M.private.randomizeTable = randomizeTable

     local function strsplit(delimiter, text)
     -- Split text into a list consisting of the strings in text, separated
     -- by strings matching delimiter (which may _NOT_ be a pattern).
     -- Example: strsplit(", ", "Anna, Bob, Charlie, Dolores")
***0     if delimiter == "" then -- this would result in endless loops
***0         error("delimiter matches empty string!")
         end
***0     local list, pos, first, last = {}, 1
         while true do
***0         first, last = text:find(delimiter, pos, true)
***0         if first then -- found?
***0             table.insert(list, text:sub(pos, first - 1))
***0             pos = last + 1
             else
***0             table.insert(list, text:sub(pos))
                 break
             end
         end
***0     return list
     end
   1 M.private.strsplit = strsplit

     local function hasNewLine( s )
         -- return true if s has a newline
***0     return (string.find(s, '\n', 1, true) ~= nil)
     end
   1 M.private.hasNewLine = hasNewLine

     local function prefixString( prefix, s )
         -- Prefix all the lines of s with prefix
***0     return prefix .. string.gsub(s, '\n', '\n' .. prefix)
     end
   1 M.private.prefixString = prefixString

     local function strMatch(s, pattern, start, final )
         -- return true if s matches completely the pattern from index start to index end
         -- return false in every other cases
         -- if start is nil, matches from the beginning of the string
         -- if final is nil, matches to the end of the string
***0     start = start or 1
***0     final = final or string.len(s)

***0     local foundStart, foundEnd = string.find(s, pattern, start, false)
***0     return foundStart == start and foundEnd == final
     end
   1 M.private.strMatch = strMatch

     local function patternFilter(patterns, expr, nil_result)
         -- Run `expr` through the inclusion and exclusion rules defined in patterns
         -- and return true if expr shall be included, false for excluded.
         -- Inclusion pattern are defined as normal patterns, exclusions 
         -- patterns start with `!` and are followed by a normal pattern
         -- If patterns is `nil` (= unset) or empty, return default value passed in `nil_result`.

  85     if patterns ~= nil and #patterns > 0 then
***0         local DONT_KNOW, ACCEPT, REJECT = nil, true, false
***0         local result = DONT_KNOW

***0         for _, pattern in ipairs(patterns) do
***0             local exclude = false
***0             if (pattern:sub(1,1) == '!') then
***0                 exclude = true
***0                 pattern = pattern:sub(2)
                 end
                 -- print('pattern: ',pattern)
                 -- print('exclude: ',exclude)

                 -- when result is not set or already accepted, match pattern
                 -- only for rejecting
***0             if exclude and (result == DONT_KNOW or result == ACCEPT) then
***0                 if string.find(expr, pattern) then
***0                     result = REJECT
                     end
                 end

                 -- when result is not set or already rejected, match pattern
                 -- only for accepting
***0             if (not exclude) and (result == DONT_KNOW or result == REJECT) then
***0                 if string.find(expr, pattern) then
***0                     result = ACCEPT
                     end
                 end
             end

***0         if result == DONT_KNOW then
                 -- when no match is found, for inclusive patterns, it means refuse expr
                 -- for negative pattern, it means accept expr
***0             return (patterns[1]:sub(1,1) == '!')
             end

***0         return result
         end

  85     return nil_result
     end
   1 M.private.patternFilter = patternFilter

     local function xmlEscape( s )
         -- Return s escaped for XML attributes
         -- escapes table:
         -- "   &quot;
         -- '   &apos;
         -- <   &lt;
         -- >   &gt;
         -- &   &amp;

***0     return string.gsub( s, '.', {
             ['&'] = "&amp;",
             ['"'] = "&quot;",
             ["'"] = "&apos;",
             ['<'] = "&lt;",
             ['>'] = "&gt;",
         } )
     end
   1 M.private.xmlEscape = xmlEscape

     local function xmlCDataEscape( s )
         -- Return s escaped for CData section, escapes: "]]>"
***0     return string.gsub( s, ']]>', ']]&gt;' )
     end
   1 M.private.xmlCDataEscape = xmlCDataEscape

     local function stripLuaunitTrace( stackTrace )
         --[[
         -- Example of  a traceback:
         <<stack traceback:
             example_with_luaunit.lua:130: in function 'test2_withFailure'
             ./luaunit.lua:1449: in function <./luaunit.lua:1449>
             [C]: in function 'xpcall'
             ./luaunit.lua:1449: in function 'protectedCall'
             ./luaunit.lua:1508: in function 'execOneFunction'
             ./luaunit.lua:1596: in function 'runSuiteByInstances'
             ./luaunit.lua:1660: in function 'runSuiteByNames'
             ./luaunit.lua:1736: in function 'runSuite'
             example_with_luaunit.lua:140: in main chunk
             [C]: in ?>>

             Other example:
         <<stack traceback:
             ./luaunit.lua:545: in function 'assertEquals'
             example_with_luaunit.lua:58: in function 'TestToto.test7'
             ./luaunit.lua:1517: in function <./luaunit.lua:1517>
             [C]: in function 'xpcall'
             ./luaunit.lua:1517: in function 'protectedCall'
             ./luaunit.lua:1578: in function 'execOneFunction'
             ./luaunit.lua:1677: in function 'runSuiteByInstances'
             ./luaunit.lua:1730: in function 'runSuiteByNames'
             ./luaunit.lua:1806: in function 'runSuite'
             example_with_luaunit.lua:140: in main chunk
             [C]: in ?>>

         <<stack traceback:
             luaunit2/example_with_luaunit.lua:124: in function 'test1_withFailure'
             luaunit2/luaunit.lua:1532: in function <luaunit2/luaunit.lua:1532>
             [C]: in function 'xpcall'
             luaunit2/luaunit.lua:1532: in function 'protectedCall'
             luaunit2/luaunit.lua:1591: in function 'execOneFunction'
             luaunit2/luaunit.lua:1679: in function 'runSuiteByInstances'
             luaunit2/luaunit.lua:1743: in function 'runSuiteByNames'
             luaunit2/luaunit.lua:1819: in function 'runSuite'
             luaunit2/example_with_luaunit.lua:140: in main chunk
             [C]: in ?>>


         -- first line is "stack traceback": KEEP
         -- next line may be luaunit line: REMOVE
         -- next lines are call in the program under testOk: REMOVE
         -- next lines are calls from luaunit to call the program under test: KEEP

         -- Strategy:
         -- keep first line
         -- remove lines that are part of luaunit
         -- kepp lines until we hit a luaunit line
         ]]

         local function isLuaunitInternalLine( s )
             -- return true if line of stack trace comes from inside luaunit
***0         return s:find('[/\\]luaunit%.lua:%d+: ') ~= nil
         end

         -- print( '<<'..stackTrace..'>>' )

***0     local t = strsplit( '\n', stackTrace )
         -- print( prettystr(t) )

***0     local idx = 2

         -- remove lines that are still part of luaunit
***0     while t[idx] and isLuaunitInternalLine( t[idx] ) do
             -- print('Removing : '..t[idx] )
***0         table.remove(t, idx)
         end

         -- keep lines until we hit luaunit again
***0     while t[idx] and (not isLuaunitInternalLine(t[idx])) do
             -- print('Keeping : '..t[idx] )
***0         idx = idx + 1
         end

         -- remove remaining luaunit lines
***0     while t[idx] do
             -- print('Removing : '..t[idx] )
***0         table.remove(t, idx)
         end

         -- print( prettystr(t) )
***0     return table.concat( t, '\n')

     end
   1 M.private.stripLuaunitTrace = stripLuaunitTrace


     local function prettystr_sub(v, indentLevel, keeponeline, printTableRefs, recursionTable )
***0     local type_v = type(v)
***0     if "string" == type_v  then
***0         if keeponeline then
***0             v = v:gsub("\n", "\\n") -- escape newline(s)
             end

             -- use clever delimiters according to content:
             -- enclose with single quotes if string contains ", but no '
***0         if v:find('"', 1, true) and not v:find("'", 1, true) then
***0             return "'" .. v .. "'"
             end
             -- use double quotes otherwise, escape embedded "
***0         return '"' .. v:gsub('"', '\\"') .. '"'

***0     elseif "table" == type_v then
             --if v.__class__ then
             --    return string.gsub( tostring(v), 'table', v.__class__ )
             --end
***0         return M.private._table_tostring(v, indentLevel, keeponeline,
***0                                             printTableRefs, recursionTable)

***0     elseif "number" == type_v then
             -- eliminate differences in formatting between various Lua versions
***0         if v ~= v then
***0             return "#NaN" -- "not a number"
             end
***0         if v == math.huge then
***0             return "#Inf" -- "infinite"
             end
***0         if v == -math.huge then
***0             return "-#Inf"
             end
***0         if _VERSION == "Lua 5.3" then
***0             local i = math.tointeger(v)
***0             if i then
***0                 return tostring(i)
                 end
             end
         end

***0     return tostring(v)
     end

     local function prettystr( v, keeponeline )
         --[[ Better string conversion, to display nice variable content:
         For strings, if keeponeline is set to true, string is displayed on one line, with visible \n
         * string are enclosed with " by default, or with ' if string contains a "
         * if table is a class, display class name
         * tables are expanded
         ]]--
***0     local recursionTable = {}
***0     local s = prettystr_sub(v, 1, keeponeline, M.PRINT_TABLE_REF_IN_ERROR_MSG, recursionTable)
***0     if recursionTable.recursionDetected and not M.PRINT_TABLE_REF_IN_ERROR_MSG then
             -- some table contain recursive references,
             -- so we must recompute the value by including all table references
             -- else the result looks like crap
***0         recursionTable = {}
***0         s = prettystr_sub(v, 1, keeponeline, true, recursionTable)
         end
***0     return s
     end
   1 M.prettystr = prettystr

     local function tryMismatchFormatting( table_a, table_b, doDeepAnalysis )
         --[[
         Prepares a nice error message when comparing tables, performing a deeper 
         analysis.

         Arguments:
         * table_a, table_b: tables to be compared
         * doDeepAnalysis:
             M.DEFAULT_DEEP_ANALYSIS: (the default if not specified) perform deep analysis only for big lists and big dictionnaries
             M.FORCE_DEEP_ANALYSIS  : always perform deep analysis
             M.DISABLE_DEEP_ANALYSIS: never perform deep analysis

         Returns: {success, result}
         * success: false if deep analysis could not be performed 
                    in this case, just use standard assertion message
         * result: if success is true, a multi-line string with deep analysis of the two lists
         ]]

         -- check if table_a & table_b are suitable for deep analysis
***0     if type(table_a) ~= 'table' or type(table_b) ~= 'table' then
***0         return false
         end

***0     if doDeepAnalysis == M.DISABLE_DEEP_ANALYSIS then
***0         return false
         end

***0     local len_a, len_b, isPureList = #table_a, #table_b, true

***0     for k1, v1 in pairs(table_a) do
***0         if type(k1) ~= 'number' or k1 > len_a then
                 -- this table a mapping
***0             isPureList = false
                 break
             end
         end

***0     if isPureList then
***0         for k2, v2 in pairs(table_b) do
***0             if type(k2) ~= 'number' or k2 > len_b then
                     -- this table a mapping
***0                 isPureList = false
                     break
                 end
             end
         end

***0     if isPureList and math.min(len_a, len_b) < M.LIST_DIFF_ANALYSIS_THRESHOLD then
***0         if not (doDeepAnalysis == M.FORCE_DEEP_ANALYSIS) then
***0             return false
             end
         end

***0     if isPureList then
***0         return M.private.mismatchFormattingPureList( table_a, table_b )
         else
             -- only work on mapping for the moment
             -- return M.private.mismatchFormattingMapping( table_a, table_b, doDeepAnalysis )
***0         return false
         end
     end
   1 M.private.tryMismatchFormatting = tryMismatchFormatting

     local function getTaTbDescr()
***0     if not M.ORDER_ACTUAL_EXPECTED then
***0         return 'expected', 'actual'
         end
***0     return 'actual', 'expected'
     end

     local function extendWithStrFmt( res, ... )
***0     table.insert( res, string.format( ... ) )
     end

     local function mismatchFormattingMapping( table_a, table_b, doDeepAnalysis )
         --[[
         Prepares a nice error message when comparing tables which are not pure lists, performing a deeper 
         analysis.

         Returns: {success, result}
         * success: false if deep analysis could not be performed 
                    in this case, just use standard assertion message
         * result: if success is true, a multi-line string with deep analysis of the two lists
         ]]

         -- disable for the moment
         --[[
         local result = {}
         local descrTa, descrTb = getTaTbDescr()

         local keysCommon = {}
         local keysOnlyTa = {}
         local keysOnlyTb = {}
         local keysDiffTaTb = {}

         local k, v

         for k,v in pairs( table_a ) do
             if is_equal( v, table_b[k] ) then
                 table.insert( keysCommon, k )
             else 
                 if table_b[k] == nil then
                     table.insert( keysOnlyTa, k )
                 else
                     table.insert( keysDiffTaTb, k )
                 end
             end
         end

         for k,v in pairs( table_b ) do
             if not is_equal( v, table_a[k] ) and table_a[k] == nil then
                 table.insert( keysOnlyTb, k )
             end
         end

         local len_a = #keysCommon + #keysDiffTaTb + #keysOnlyTa
         local len_b = #keysCommon + #keysDiffTaTb + #keysOnlyTb
         local limited_display = (len_a < 5 or len_b < 5)

         if math.min(len_a, len_b) < M.TABLE_DIFF_ANALYSIS_THRESHOLD then
             return false
         end

         if not limited_display then
             if len_a == len_b then
                 extendWithStrFmt( result, 'Table A (%s) and B (%s) both have %d items', descrTa, descrTb, len_a )
             else
                 extendWithStrFmt( result, 'Table A (%s) has %d items and table B (%s) has %d items', descrTa, len_a, descrTb, len_b )
                 end

             if #keysCommon == 0 and #keysDiffTaTb == 0 then
                 table.insert( result, 'Table A and B have no keys in common, they are totally different')
             else
                 local s_other = 'other '
                 if #keysCommon then
                     extendWithStrFmt( result, 'Table A and B have %d identical items', #keysCommon )
                 else
                     table.insert( result, 'Table A and B have no identical items' )
                     s_other = ''
                 end

                 if #keysDiffTaTb ~= 0 then
                     result[#result] = string.format( '%s and %d items differing present in both tables', result[#result], #keysDiffTaTb)
                 else
                     result[#result] = string.format( '%s and no %sitems differing present in both tables', result[#result], s_other, #keysDiffTaTb)
                 end
             end

             extendWithStrFmt( result, 'Table A has %d keys not present in table B and table B has %d keys not present in table A', #keysOnlyTa, #keysOnlyTb ) 
         end

         local function keytostring(k)
             if "string" == type(k) and k:match("^[_%a][_%w]*$") then
                 return k
             end
             return prettystr(k)
         end

         if #keysDiffTaTb ~= 0 then
             table.insert( result, 'Items differing in A and B:')
             for k,v in sortedPairs( keysDiffTaTb ) do
                 extendWithStrFmt( result, '  - A[%s]: %s', keytostring(v), prettystr(table_a[v]) )
                 extendWithStrFmt( result, '  + B[%s]: %s', keytostring(v), prettystr(table_b[v]) )
             end
         end    

         if #keysOnlyTa ~= 0 then
             table.insert( result, 'Items only in table A:' )
             for k,v in sortedPairs( keysOnlyTa ) do
                 extendWithStrFmt( result, '  - A[%s]: %s', keytostring(v), prettystr(table_a[v]) )
             end
         end

         if #keysOnlyTb ~= 0 then
             table.insert( result, 'Items only in table B:' )
             for k,v in sortedPairs( keysOnlyTb ) do
                 extendWithStrFmt( result, '  + B[%s]: %s', keytostring(v), prettystr(table_b[v]) )
             end
         end

         if #keysCommon ~= 0 then
             table.insert( result, 'Items common to A and B:')
             for k,v in sortedPairs( keysCommon ) do
                 extendWithStrFmt( result, '  = A and B [%s]: %s', keytostring(v), prettystr(table_a[v]) )
             end
         end    

         return true, table.concat( result, '\n')
         ]]
     end
   1 M.private.mismatchFormattingMapping = mismatchFormattingMapping

     local function mismatchFormattingPureList( table_a, table_b )
         --[[
         Prepares a nice error message when comparing tables which are lists, performing a deeper 
         analysis.

         Returns: {success, result}
         * success: false if deep analysis could not be performed 
                    in this case, just use standard assertion message
         * result: if success is true, a multi-line string with deep analysis of the two lists
         ]]
***0     local result, descrTa, descrTb = {}, getTaTbDescr()

***0     local len_a, len_b, refa, refb = #table_a, #table_b, '', ''
***0     if M.PRINT_TABLE_REF_IN_ERROR_MSG then
***0         refa, refb = string.format( '<%s> ', tostring(table_a)), string.format('<%s> ', tostring(table_b) )
         end
***0     local longest, shortest = math.max(len_a, len_b), math.min(len_a, len_b)
***0     local deltalv  = longest - shortest

***0     local commonUntil = longest
***0     for i = 1, longest do
***0         if not is_equal(table_a[i], table_b[i]) then
***0             commonUntil = i - 1
                 break
             end
         end

***0     local commonBackTo = shortest - 1
***0     for i = 0, shortest - 1 do
***0         if not is_equal(table_a[len_a-i], table_b[len_b-i]) then
***0             commonBackTo = i - 1
                 break
             end
         end


***0     table.insert( result, 'List difference analysis:' )    
***0     if len_a == len_b then
             -- TODO: handle expected/actual naming
***0         extendWithStrFmt( result, '* lists %sA (%s) and %sB (%s) have the same size', refa, descrTa, refb, descrTb )
         else 
***0         extendWithStrFmt( result, '* list sizes differ: list %sA (%s) has %d items, list %sB (%s) has %d items', refa, descrTa, len_a, refb, descrTb, len_b )
         end

***0     extendWithStrFmt( result, '* lists A and B start differing at index %d', commonUntil+1 ) 
***0     if commonBackTo >= 0 then
***0         if deltalv > 0 then
***0             extendWithStrFmt( result, '* lists A and B are equal again from index %d for A, %d for B', len_a-commonBackTo, len_b-commonBackTo )
             else
***0             extendWithStrFmt( result, '* lists A and B are equal again from index %d', len_a-commonBackTo )
             end
         end

         local function insertABValue(ai, bi)
***0         bi = bi or ai
***0         if is_equal( table_a[ai], table_b[bi]) then
***0             return extendWithStrFmt( result, '  = A[%d], B[%d]: %s', ai, bi, prettystr(table_a[ai]) )
             else
***0             extendWithStrFmt( result, '  - A[%d]: %s', ai, prettystr(table_a[ai]))
***0             extendWithStrFmt( result, '  + B[%d]: %s', bi, prettystr(table_b[bi]))
             end
         end

         -- common parts to list A & B, at the beginning
***0     if commonUntil > 0 then
***0         table.insert( result, '* Common parts:' )
***0         for i = 1, commonUntil do
***0             insertABValue( i )
             end
         end

         -- diffing parts to list A & B
***0     if commonUntil < shortest - commonBackTo - 1 then
***0         table.insert( result, '* Differing parts:' )
***0         for i = commonUntil + 1, shortest - commonBackTo - 1 do
***0             insertABValue( i )
             end
         end

         -- display indexes of one list, with no match on other list
***0     if shortest - commonBackTo <= longest - commonBackTo - 1 then
***0         table.insert( result, '* Present only in one list:' )
***0         for i = shortest - commonBackTo, longest - commonBackTo - 1 do
***0             if len_a > len_b then
***0                 extendWithStrFmt( result, '  - A[%d]: %s', i, prettystr(table_a[i]) )
                     -- table.insert( result, '+ (no matching B index)')
                 else
                     -- table.insert( result, '- no matching A index')
***0                 extendWithStrFmt( result, '  + B[%d]: %s', i, prettystr(table_b[i]) )
                 end
             end
         end

         -- common parts to list A & B, at the end
***0     if commonBackTo >= 0 then
***0         table.insert( result, '* Common parts at the end of the lists' )
***0         for i = longest - commonBackTo, longest do
***0             if len_a > len_b then
***0                 insertABValue( i, i-deltalv )
                 else
***0                 insertABValue( i-deltalv, i )
                 end
             end
         end

***0     return true, table.concat( result, '\n')
     end
   1 M.private.mismatchFormattingPureList = mismatchFormattingPureList

     local function prettystrPairs(value1, value2, suffix_a, suffix_b)
         --[[
         This function helps with the recurring task of constructing the "expected
         vs. actual" error messages. It takes two arbitrary values and formats
         corresponding strings with prettystr().

         To keep the (possibly complex) output more readable in case the resulting
         strings contain line breaks, they get automatically prefixed with additional
         newlines. Both suffixes are optional (default to empty strings), and get
         appended to the "value1" string. "suffix_a" is used if line breaks were
         encountered, "suffix_b" otherwise.

         Returns the two formatted strings (including padding/newlines).
         ]]
***0     local str1, str2 = prettystr(value1), prettystr(value2)
***0     if hasNewLine(str1) or hasNewLine(str2) then
             -- line break(s) detected, add padding
***0         return "\n" .. str1 .. (suffix_a or ""), "\n" .. str2
         end
***0     return str1 .. (suffix_b or ""), str2
     end
   1 M.private.prettystrPairs = prettystrPairs

   1 local TABLE_TOSTRING_SEP = ", "
   1 local TABLE_TOSTRING_SEP_LEN = string.len(TABLE_TOSTRING_SEP)


     local function _table_tostring( tbl, indentLevel, keeponeline, printTableRefs, recursionTable )
***0     printTableRefs = printTableRefs or M.PRINT_TABLE_REF_IN_ERROR_MSG
***0     recursionTable = recursionTable or {}
***0     recursionTable[tbl] = true

***0     local result, dispOnMultLines = {}, false

         -- like prettystr but do not enclose with "" if the string is just alphanumerical
         -- this is better for displaying table keys who are often simple strings
         local function keytostring(k)
***0         if "string" == type(k) and k:match("^[_%a][_%w]*$") then
***0             return k
             end
***0         return prettystr_sub(k, indentLevel+1, true, printTableRefs, recursionTable)
         end

***0     local entry, count, seq_index = nil, 0, 1
***0     for k, v in sortedPairs( tbl ) do
***0         if k == seq_index then
                 -- for the sequential part of tables, we'll skip the "<key>=" output
***0             entry = ''
***0             seq_index = seq_index + 1
***0         elseif recursionTable[k] then
                 -- recursion in the key detected
***0             recursionTable.recursionDetected = true
***0             entry = "<"..tostring(k)..">="
             else
***0             entry = keytostring(k) .. "="
             end
***0         if recursionTable[v] then
                 -- recursion in the value detected!
***0             recursionTable.recursionDetected = true
***0             entry = entry .. "<"..tostring(v)..">"
             else
***0             entry = entry ..
***0                 prettystr_sub( v, indentLevel+1, keeponeline, printTableRefs, recursionTable )
             end
***0         count = count + 1
***0         result[count] = entry
         end

***0     if not keeponeline then
             -- set dispOnMultLines if the maximum LINE_LENGTH would be exceeded
***0         local totalLength = 0
***0         for k, v in ipairs( result ) do
***0             totalLength = totalLength + string.len( v )
***0             if totalLength >= M.LINE_LENGTH then
***0                 dispOnMultLines = true
                     break
                 end
             end

***0         if not dispOnMultLines then
                 -- adjust with length of separator(s):
                 -- two items need 1 sep, three items two seps, ... plus len of '{}'
***0             if count > 0 then
***0                 totalLength = totalLength + TABLE_TOSTRING_SEP_LEN * (count - 1)
                 end
***0             dispOnMultLines = totalLength + 2 >= M.LINE_LENGTH
             end
         end

         -- now reformat the result table (currently holding element strings)
***0     if dispOnMultLines then
***0         local indentString = string.rep("    ", indentLevel - 1)
             result = {"{\n    ", indentString,
***0                   table.concat(result, ",\n    " .. indentString), "\n",
***0                   indentString, "}"}
         else
***0         result = {"{", table.concat(result, TABLE_TOSTRING_SEP), "}"}
         end
***0     if printTableRefs then
***0         table.insert(result, 1, "<"..tostring(tbl).."> ") -- prepend table ref
         end
***0     return table.concat(result)
     end
   1 M.private._table_tostring = _table_tostring -- prettystr_sub() needs it

     local function _table_contains(t, element)
 126     if type(t) == "table" then
 126         local type_e = type(element)
 456         for _, value in pairs(t) do
 456             if type(value) == type_e then
 456                 if value == element then
  42                     return true
                     end
 414                 if type_e == 'table' then
                         -- if we wanted recursive items content comparison, we could use
                         -- _is_table_items_equals(v, expected) but one level of just comparing
                         -- items is sufficient
 384                     if M.private._is_table_equals( value, element ) then
  84                         return true
                         end
                     end
                 end
             end
         end
***0     return false
     end

     local function _is_table_items_equals(actual, expected )
  16     local type_a, type_e = type(actual), type(expected)

  16     if (type_a == 'table') and (type_e == 'table') then
  79         for k, v in pairs(actual) do
  63             if not _table_contains(expected, v) then
***0                 return false
                 end
             end
  79         for k, v in pairs(expected) do
  63             if not _table_contains(actual, v) then
***0                 return false
                 end
             end
  16         return true

***0     elseif type_a ~= type_e then
***0         return false

***0     elseif actual ~= expected then
***0         return false
         end

***0     return true
     end

     --[[
     This is a specialized metatable to help with the bookkeeping of recursions
     in _is_table_equals(). It provides an __index table that implements utility
     functions for easier management of the table. The "cached" method queries
     the state of a specific (actual,expected) pair; and the "store" method sets
     this state to the given value. The state of pairs not "seen" / visited is
     assumed to be `nil`.
     ]]
   1 local _recursion_cache_MT = {
   1     __index = {
             -- Return the cached value for an (actual,expected) pair (or `nil`)
             cached = function(t, actual, expected)
 384             local subtable = t[actual] or {}
 384             return subtable[expected]
             end,

             -- Store cached value for a specific (actual,expected) pair.
             -- Returns the value, so it's easy to use for a "tailcall" (return ...).
             store = function(t, actual, expected, value, asymmetric)
 938             local subtable = t[actual]
 938             if not subtable then
 770                 subtable = {}
 770                 t[actual] = subtable
                 end
 938             subtable[expected] = value

                 -- Unless explicitly marked "asymmetric": Consider the recursion
                 -- on (expected,actual) to be equivalent to (actual,expected) by
                 -- default, and thus cache the value for both.
 938             if not asymmetric then
 469                 t:store(expected, actual, value, true)
                 end

 938             return value
             end
   1     }
     }

     local function _is_table_equals(actual, expected, recursions)
 937     local type_a, type_e = type(actual), type(expected)
 937     recursions = recursions or setmetatable({}, _recursion_cache_MT)

 937     if type_a ~= type_e then
***0         return false -- different types won't match
         end

 937     if (type_a == 'table') --[[ and (type_e == 'table') ]] then
 385         if actual == expected then
                 -- Both reference the same table, so they are actually identical
   1             return recursions:store(actual, expected, true)
             end

             -- If we've tested this (actual,expected) pair before: return cached value
 384         local previous = recursions:cached(actual, expected)
 384         if previous ~= nil then
***0             return previous
             end

             -- Mark this (actual,expected) pair, so we won't recurse it again. For
             -- now, assume a "false" result, which we might adjust later if needed.
 384         recursions:store(actual, expected, false)

             -- Tables must have identical element count, or they can't match.
 384         if (#actual ~= #expected) then
***0             return false
             end

 384         local actualKeysMatched, actualTableKeys = {}, {}

 636         for k, v in pairs(actual) do
 552             if M.TABLE_EQUALS_KEYBYCONTENT and type(k) == "table" then
                     -- If the keys are tables, things get a bit tricky here as we
                     -- can have _is_table_equals(t[k1], t[k2]) despite k1 ~= k2. So
                     -- we first collect table keys from "actual", and then later try
                     -- to match each table key from "expected" to actualTableKeys.
***0                 table.insert(actualTableKeys, k)
                 else
 552                 if not _is_table_equals(v, expected[k], recursions) then
 300                     return false -- Mismatch on value, tables can't be equal
                     end
 252                 actualKeysMatched[k] = true -- Keep track of matched keys
                 end
             end

 336         for k, v in pairs(expected) do
 252             if M.TABLE_EQUALS_KEYBYCONTENT and type(k) == "table" then
***0                 local found = false
                     -- Note: DON'T use ipairs() here, table may be non-sequential!
***0                 for i, candidate in pairs(actualTableKeys) do
***0                     if _is_table_equals(candidate, k, recursions) then
***0                         if _is_table_equals(actual[candidate], v, recursions) then
***0                             found = true
                                 -- Remove the candidate we matched against from the list
                                 -- of table keys, so each key in actual can only match
                                 -- one key in expected.
***0                             actualTableKeys[i] = nil
                                 break
                             end
                             -- keys match but values don't, keep searching
                         end
                     end
***0                 if not found then
***0                     return false -- no matching (key,value) pair
                     end
                 else
 252                 if not actualKeysMatched[k] then
                         -- Found a key that we did not see in "actual" -> mismatch
***0                     return false
                     end
                     -- Otherwise actual[k] was already matched against v = expected[k].
                 end
             end

  84         if next(actualTableKeys) then
                 -- If there is any key left in actualTableKeys, then that is
                 -- a table-type key in actual with no matching counterpart
                 -- (in expected), and so the tables aren't equal.
***0             return false
             end

             -- The tables are actually considered equal, update cache and return result
  84         return recursions:store(actual, expected, true)

 552     elseif actual ~= expected then
 300         return false
         end

 252     return true
     end
   1 M.private._is_table_equals = _is_table_equals
   1 is_equal = _is_table_equals

     local function failure(msg, level)
         -- raise an error indicating a test failure
         -- for error() compatibility we adjust "level" here (by +1), to report the
         -- calling context
***0     error(M.FAILURE_PREFIX .. msg, (level or 1) + 1)
     end

     local function fail_fmt(level, ...)
          -- failure with printf-style formatted message and given error level
***0     failure(string.format(...), (level or 1) + 1)
     end
   1 M.private.fail_fmt = fail_fmt

     local function error_fmt(level, ...)
          -- printf-style error()
***0     error(string.format(...), (level or 1) + 1)
     end

     ----------------------------------------------------------------
     --
     --                     assertions
     --
     ----------------------------------------------------------------

     local function errorMsgEquality(actual, expected, doDeepAnalysis)

***0     if not M.ORDER_ACTUAL_EXPECTED then
***0         expected, actual = actual, expected
         end
***0     if type(expected) == 'string' or type(expected) == 'table' then
***0         local strExpected, strActual = prettystrPairs(expected, actual)
***0         local result = string.format("expected: %s\nactual: %s", strExpected, strActual)

             -- extend with mismatch analysis if possible:
             local success, mismatchResult
***0         success, mismatchResult = tryMismatchFormatting( actual, expected, doDeepAnalysis )
***0         if success then 
***0             result = table.concat( { result, mismatchResult }, '\n' )
             end
***0         return result
         end
***0     return string.format("expected: %s, actual: %s",
***0                          prettystr(expected), prettystr(actual))
     end

   1 function M.assertError(f, ...)
         -- assert that calling f with the arguments will raise an error
         -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
***0     if pcall( f, ... ) then
***0         failure( "Expected an error when calling function but no error generated", 2 )
         end
     end

   1 function M.assertEvalToTrue(value)
***0     if not value then
***0         failure("expected: a value evaluating to true, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertEvalToFalse(value)
***0     if value then
***0         failure("expected: false or nil, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertIsTrue(value)
 171     if value ~= true then
***0         failure("expected: true, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertNotIsTrue(value)
***0     if value == true then
***0         failure("expected: anything but true, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertIsFalse(value)
 152     if value ~= false then
***0         failure("expected: false, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertNotIsFalse(value)
***0     if value == false then
***0         failure("expected: anything but false, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertIsNil(value)
   1     if value ~= nil then
***0         failure("expected: nil, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertNotIsNil(value)
***0     if value == nil then
***0         failure("expected non nil value, received nil", 2)
         end
     end

   1 function M.assertIsNaN(value)
***0     if type(value) ~= "number" or value == value then
***0         failure("expected: nan, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertNotIsNaN(value)
***0     if type(value) == "number" and value ~= value then
***0         failure("expected non nan value, received nan", 2)
         end
     end

   1 function M.assertIsInf(value)
***0     if type(value) ~= "number" or math.abs(value) ~= math.huge then
***0         failure("expected: inf, actual: " ..prettystr(value), 2)
         end
     end

   1 function M.assertNotIsInf(value)
***0     if type(value) == "number" and math.abs(value) == math.huge then
***0         failure("expected non inf value, received ±inf", 2)
         end
     end

   1 function M.assertEquals(actual, expected, doDeepAnalysis)
 125     if type(actual) == 'table' and type(expected) == 'table' then
   1         if not _is_table_equals(actual, expected) then
***0             failure( errorMsgEquality(actual, expected, doDeepAnalysis), 2 )
             end
 124     elseif type(actual) ~= type(expected) then
***0         failure( errorMsgEquality(actual, expected), 2 )
 124     elseif actual ~= expected then
***0         failure( errorMsgEquality(actual, expected), 2 )
         end
     end

   1 function M.almostEquals( actual, expected, margin )
***0     if type(actual) ~= 'number' or type(expected) ~= 'number' or type(margin) ~= 'number' then
***0         error_fmt(3, 'almostEquals: must supply only number arguments.\nArguments supplied: %s, %s, %s',
***0             prettystr(actual), prettystr(expected), prettystr(margin))
         end
***0     if margin < 0 then
***0         error('almostEquals: margin must not be negative, current value is ' .. margin, 3)
         end
***0     return math.abs(expected - actual) <= margin
     end

   1 function M.assertAlmostEquals( actual, expected, margin )
         -- check that two floats are close by margin
***0     margin = margin or M.EPSILON
***0     if not M.almostEquals(actual, expected, margin) then
***0         if not M.ORDER_ACTUAL_EXPECTED then
***0             expected, actual = actual, expected
             end
***0         local delta = math.abs(actual - expected) - margin
***0         fail_fmt(2, 'Values are not almost equal\n' ..
                         'Actual: %s, expected: %s with margin of %s; delta: %s',
***0                     actual, expected, margin, delta)
         end
     end

   1 function M.assertNotEquals(actual, expected)
   2     if type(actual) ~= type(expected) then
   2         return
         end

***0     if type(actual) == 'table' and type(expected) == 'table' then
***0         if not _is_table_equals(actual, expected) then
***0             return
             end
***0     elseif actual ~= expected then
***0         return
         end
***0     fail_fmt(2, 'Received the not expected value: %s', prettystr(actual))
     end

   1 function M.assertNotAlmostEquals( actual, expected, margin )
         -- check that two floats are not close by margin
***0     margin = margin or M.EPSILON
***0     if M.almostEquals(actual, expected, margin) then
***0         if not M.ORDER_ACTUAL_EXPECTED then
***0             expected, actual = actual, expected
             end
***0         local delta = margin - math.abs(actual - expected)
***0         fail_fmt(2, 'Values are almost equal\nActual: %s, expected: %s' ..
                         ' with a difference above margin of %s; delta: %s',
***0                     actual, expected, margin, delta)
         end
     end

   1 function M.assertStrContains( str, sub, useRe )
         -- this relies on lua string.find function
         -- a string always contains the empty string
***0     if not string.find(str, sub, 1, not useRe) then
***0         sub, str = prettystrPairs(sub, str, '\n')
***0         fail_fmt(2, 'Error, %s %s was not found in string %s',
***0                  useRe and 'regexp' or 'substring', sub, str)
         end
     end

   1 function M.assertStrIContains( str, sub )
         -- this relies on lua string.find function
         -- a string always contains the empty string
***0     if not string.find(str:lower(), sub:lower(), 1, true) then
***0         sub, str = prettystrPairs(sub, str, '\n')
***0         fail_fmt(2, 'Error, substring %s was not found (case insensitively) in string %s',
***0                  sub, str)
         end
     end

   1 function M.assertNotStrContains( str, sub, useRe )
         -- this relies on lua string.find function
         -- a string always contains the empty string
***0     if string.find(str, sub, 1, not useRe) then
***0         sub, str = prettystrPairs(sub, str, '\n')
***0         fail_fmt(2, 'Error, %s %s was found in string %s',
***0                  useRe and 'regexp' or 'substring', sub, str)
         end
     end

   1 function M.assertNotStrIContains( str, sub )
         -- this relies on lua string.find function
         -- a string always contains the empty string
***0     if string.find(str:lower(), sub:lower(), 1, true) then
***0         sub, str = prettystrPairs(sub, str, '\n')
***0         fail_fmt(2, 'Error, substring %s was found (case insensitively) in string %s',
***0                  sub, str)
         end
     end

   1 function M.assertStrMatches( str, pattern, start, final )
         -- Verify a full match for the string
         -- for a partial match, simply use assertStrContains with useRe set to true
***0     if not strMatch( str, pattern, start, final ) then
***0         pattern, str = prettystrPairs(pattern, str, '\n')
***0         fail_fmt(2, 'Error, pattern %s was not matched by string %s',
***0                  pattern, str)
         end
     end

   1 function M.assertErrorMsgEquals( expectedMsg, func, ... )
         -- assert that calling f with the arguments will raise an error
         -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
***0     local no_error, error_msg = pcall( func, ... )
***0     if no_error then
***0         failure( 'No error generated when calling function but expected error: "'..expectedMsg..'"', 2 )
         end
***0     if error_msg ~= expectedMsg then
***0         error_msg, expectedMsg = prettystrPairs(error_msg, expectedMsg)
***0         fail_fmt(2, 'Exact error message expected: %s\nError message received: %s\n',
***0                  expectedMsg, error_msg)
         end
     end

   1 function M.assertErrorMsgContains( partialMsg, func, ... )
         -- assert that calling f with the arguments will raise an error
         -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
  17     local no_error, error_msg = pcall( func, ... )
  17     if no_error then
***0         failure( 'No error generated when calling function but expected error containing: '..prettystr(partialMsg), 2 )
         end
  17     if not string.find( error_msg, partialMsg, nil, true ) then
***0         error_msg, partialMsg = prettystrPairs(error_msg, partialMsg)
***0         fail_fmt(2, 'Error message does not contain: %s\nError message received: %s\n',
***0                  partialMsg, error_msg)
         end
     end

   1 function M.assertErrorMsgMatches( expectedMsg, func, ... )
         -- assert that calling f with the arguments will raise an error
         -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
***0     local no_error, error_msg = pcall( func, ... )
***0     if no_error then
***0         failure( 'No error generated when calling function but expected error matching: "'..expectedMsg..'"', 2 )
         end
***0     if not strMatch( error_msg, expectedMsg ) then
***0         expectedMsg, error_msg = prettystrPairs(expectedMsg, error_msg)
***0         fail_fmt(2, 'Error message does not match: %s\nError message received: %s\n',
***0                  expectedMsg, error_msg)
         end
     end

     --[[
     Add type assertion functions to the module table M. Each of these functions
     takes a single parameter "value", and checks that its Lua type matches the
     expected string (derived from the function name):

     M.assertIsXxx(value) -> ensure that type(value) conforms to "xxx"
     ]]
  10 for _, funcName in ipairs(
   1     {'assertIsNumber', 'assertIsString', 'assertIsTable', 'assertIsBoolean',
   1      'assertIsFunction', 'assertIsUserdata', 'assertIsThread'}
   1 ) do
   7     local typeExpected = funcName:match("^assertIs([A-Z]%a*)$")
         -- Lua type() always returns lowercase, also make sure the match() succeeded
   7     typeExpected = typeExpected and typeExpected:lower()
   7                    or error("bad function name '"..funcName.."' for type assertion")

         M[funcName] = function(value)
   5         if type(value) ~= typeExpected then
***0             fail_fmt(2, 'Expected: a %s value, actual: type %s, value %s',
***0                      typeExpected, type(value), prettystrPairs(value))
             end
         end
     end

     --[[
     Add shortcuts for verifying type of a variable, without failure (luaunit v2 compatibility)
     M.isXxx(value) -> returns true if type(value) conforms to "xxx"
     ]]
  11 for _, typeExpected in ipairs(
   1     {'Number', 'String', 'Table', 'Boolean',
   1      'Function', 'Userdata', 'Thread', 'Nil' }
   1 ) do
   8     local typeExpectedLower = typeExpected:lower()
         local isType = function(value)
***0         return (type(value) == typeExpectedLower)
         end
   8     M['is'..typeExpected] = isType
   8     M['is_'..typeExpectedLower] = isType
     end

     --[[
     Add non-type assertion functions to the module table M. Each of these functions
     takes a single parameter "value", and checks that its Lua type differs from the
     expected string (derived from the function name):

     M.assertNotIsXxx(value) -> ensure that type(value) is not "xxx"
     ]]
  10 for _, funcName in ipairs(
   1     {'assertNotIsNumber', 'assertNotIsString', 'assertNotIsTable', 'assertNotIsBoolean',
   1      'assertNotIsFunction', 'assertNotIsUserdata', 'assertNotIsThread'}
   1 ) do
   7     local typeUnexpected = funcName:match("^assertNotIs([A-Z]%a*)$")
         -- Lua type() always returns lowercase, also make sure the match() succeeded
   7     typeUnexpected = typeUnexpected and typeUnexpected:lower()
   7                    or error("bad function name '"..funcName.."' for type assertion")

         M[funcName] = function(value)
***0         if type(value) == typeUnexpected then
***0             fail_fmt(2, 'Not expected: a %s type, actual: value %s',
***0                      typeUnexpected, prettystrPairs(value))
             end
         end
     end

   1 function M.assertIs(actual, expected)
***0     if actual ~= expected then
***0         if not M.ORDER_ACTUAL_EXPECTED then
***0             actual, expected = expected, actual
             end
***0         expected, actual = prettystrPairs(expected, actual, '\n', ', ')
***0         fail_fmt(2, 'Expected object and actual object are not the same\nExpected: %sactual: %s',
***0                  expected, actual)
         end
     end

   1 function M.assertNotIs(actual, expected)
***0     if actual == expected then
***0         if not M.ORDER_ACTUAL_EXPECTED then
***0             expected = actual
             end
***0         fail_fmt(2, 'Expected object and actual object are the same object: %s',
***0                  prettystrPairs(expected))
         end
     end

   1 function M.assertItemsEquals(actual, expected)
         -- checks that the items of table expected
         -- are contained in table actual. Warning, this function
         -- is at least O(n^2)
  16     if not _is_table_items_equals(actual, expected ) then
***0         expected, actual = prettystrPairs(expected, actual)
***0         fail_fmt(2, 'Contents of the tables are not identical:\nExpected: %s\nActual: %s',
***0                  expected, actual)
         end
     end

     ----------------------------------------------------------------
     --                     Compatibility layer
     ----------------------------------------------------------------

     -- for compatibility with LuaUnit v2.x
   1 function M.wrapFunctions()
         -- In LuaUnit version <= 2.1 , this function was necessary to include
         -- a test function inside the global test suite. Nowadays, the functions
         -- are simply run directly as part of the test discovery process.
         -- so just do nothing !
***0     io.stderr:write[[Use of WrapFunctions() is no longer needed.
     Just prefix your test function names with "test" or "Test" and they
     will be picked up and run by LuaUnit.
***0 ]]
     end

   1 local list_of_funcs = {
         -- { official function name , alias }

         -- general assertions
   1     { 'assertEquals'            , 'assert_equals' },
   1     { 'assertItemsEquals'       , 'assert_items_equals' },
   1     { 'assertNotEquals'         , 'assert_not_equals' },
   1     { 'assertAlmostEquals'      , 'assert_almost_equals' },
   1     { 'assertNotAlmostEquals'   , 'assert_not_almost_equals' },
   1     { 'assertEvalToTrue'        , 'assert_eval_to_true' },
   1     { 'assertEvalToFalse'       , 'assert_eval_to_false' },
   1     { 'assertStrContains'       , 'assert_str_contains' },
   1     { 'assertStrIContains'      , 'assert_str_icontains' },
   1     { 'assertNotStrContains'    , 'assert_not_str_contains' },
   1     { 'assertNotStrIContains'   , 'assert_not_str_icontains' },
   1     { 'assertStrMatches'        , 'assert_str_matches' },
   1     { 'assertError'             , 'assert_error' },
   1     { 'assertErrorMsgEquals'    , 'assert_error_msg_equals' },
   1     { 'assertErrorMsgContains'  , 'assert_error_msg_contains' },
   1     { 'assertErrorMsgMatches'   , 'assert_error_msg_matches' },
   1     { 'assertIs'                , 'assert_is' },
   1     { 'assertNotIs'             , 'assert_not_is' },
   1     { 'wrapFunctions'           , 'WrapFunctions' },
   1     { 'wrapFunctions'           , 'wrap_functions' },

         -- type assertions: assertIsXXX -> assert_is_xxx
   1     { 'assertIsNumber'          , 'assert_is_number' },
   1     { 'assertIsString'          , 'assert_is_string' },
   1     { 'assertIsTable'           , 'assert_is_table' },
   1     { 'assertIsBoolean'         , 'assert_is_boolean' },
   1     { 'assertIsNil'             , 'assert_is_nil' },
   1     { 'assertIsTrue'            , 'assert_is_true' },
   1     { 'assertIsFalse'           , 'assert_is_false' },
   1     { 'assertIsNaN'             , 'assert_is_nan' },
   1     { 'assertIsInf'             , 'assert_is_inf' },
   1     { 'assertIsFunction'        , 'assert_is_function' },
   1     { 'assertIsThread'          , 'assert_is_thread' },
   1     { 'assertIsUserdata'        , 'assert_is_userdata' },

         -- type assertions: assertIsXXX -> assertXxx
   1     { 'assertIsNumber'          , 'assertNumber' },
   1     { 'assertIsString'          , 'assertString' },
   1     { 'assertIsTable'           , 'assertTable' },
   1     { 'assertIsBoolean'         , 'assertBoolean' },
   1     { 'assertIsNil'             , 'assertNil' },
   1     { 'assertIsTrue'            , 'assertTrue' },
   1     { 'assertIsFalse'           , 'assertFalse' },
   1     { 'assertIsNaN'             , 'assertNaN' },
   1     { 'assertIsInf'             , 'assertInf' },
   1     { 'assertIsFunction'        , 'assertFunction' },
   1     { 'assertIsThread'          , 'assertThread' },
   1     { 'assertIsUserdata'        , 'assertUserdata' },

         -- type assertions: assertIsXXX -> assert_xxx (luaunit v2 compat)
   1     { 'assertIsNumber'          , 'assert_number' },
   1     { 'assertIsString'          , 'assert_string' },
   1     { 'assertIsTable'           , 'assert_table' },
   1     { 'assertIsBoolean'         , 'assert_boolean' },
   1     { 'assertIsNil'             , 'assert_nil' },
   1     { 'assertIsTrue'            , 'assert_true' },
   1     { 'assertIsFalse'           , 'assert_false' },
   1     { 'assertIsNaN'             , 'assert_nan' },
   1     { 'assertIsInf'             , 'assert_inf' },
   1     { 'assertIsFunction'        , 'assert_function' },
   1     { 'assertIsThread'          , 'assert_thread' },
   1     { 'assertIsUserdata'        , 'assert_userdata' },

         -- type assertions: assertNotIsXXX -> assert_not_is_xxx
   1     { 'assertNotIsNumber'       , 'assert_not_is_number' },
   1     { 'assertNotIsString'       , 'assert_not_is_string' },
   1     { 'assertNotIsTable'        , 'assert_not_is_table' },
   1     { 'assertNotIsBoolean'      , 'assert_not_is_boolean' },
   1     { 'assertNotIsNil'          , 'assert_not_is_nil' },
   1     { 'assertNotIsTrue'         , 'assert_not_is_true' },
   1     { 'assertNotIsFalse'        , 'assert_not_is_false' },
   1     { 'assertNotIsNaN'          , 'assert_not_is_nan' },
   1     { 'assertNotIsInf'          , 'assert_not_is_inf' },
   1     { 'assertNotIsFunction'     , 'assert_not_is_function' },
   1     { 'assertNotIsThread'       , 'assert_not_is_thread' },
   1     { 'assertNotIsUserdata'     , 'assert_not_is_userdata' },

         -- type assertions: assertNotIsXXX -> assertNotXxx (luaunit v2 compat)
   1     { 'assertNotIsNumber'       , 'assertNotNumber' },
   1     { 'assertNotIsString'       , 'assertNotString' },
   1     { 'assertNotIsTable'        , 'assertNotTable' },
   1     { 'assertNotIsBoolean'      , 'assertNotBoolean' },
   1     { 'assertNotIsNil'          , 'assertNotNil' },
   1     { 'assertNotIsTrue'         , 'assertNotTrue' },
   1     { 'assertNotIsFalse'        , 'assertNotFalse' },
   1     { 'assertNotIsNaN'          , 'assertNotNaN' },
   1     { 'assertNotIsInf'          , 'assertNotInf' },
   1     { 'assertNotIsFunction'     , 'assertNotFunction' },
   1     { 'assertNotIsThread'       , 'assertNotThread' },
   1     { 'assertNotIsUserdata'     , 'assertNotUserdata' },

         -- type assertions: assertNotIsXXX -> assert_not_xxx
   1     { 'assertNotIsNumber'       , 'assert_not_number' },
   1     { 'assertNotIsString'       , 'assert_not_string' },
   1     { 'assertNotIsTable'        , 'assert_not_table' },
   1     { 'assertNotIsBoolean'      , 'assert_not_boolean' },
   1     { 'assertNotIsNil'          , 'assert_not_nil' },
   1     { 'assertNotIsTrue'         , 'assert_not_true' },
   1     { 'assertNotIsFalse'        , 'assert_not_false' },
   1     { 'assertNotIsNaN'          , 'assert_not_nan' },
   1     { 'assertNotIsInf'          , 'assert_not_inf' },
   1     { 'assertNotIsFunction'     , 'assert_not_function' },
   1     { 'assertNotIsThread'       , 'assert_not_thread' },
   1     { 'assertNotIsUserdata'     , 'assert_not_userdata' },

         -- all assertions with Coroutine duplicate Thread assertions
   1     { 'assertIsThread'          , 'assertIsCoroutine' },
   1     { 'assertIsThread'          , 'assertCoroutine' },
   1     { 'assertIsThread'          , 'assert_is_coroutine' },
   1     { 'assertIsThread'          , 'assert_coroutine' },
   1     { 'assertNotIsThread'       , 'assertNotIsCoroutine' },
   1     { 'assertNotIsThread'       , 'assertNotCoroutine' },
   1     { 'assertNotIsThread'       , 'assert_not_is_coroutine' },
   1     { 'assertNotIsThread'       , 'assert_not_coroutine' },
   1 }

     -- Create all aliases in M
 101 for _,v in ipairs( list_of_funcs ) do
 100     local funcname, alias = v[1], v[2]
 100     M[alias] = M[funcname]

 100     if EXPORT_ASSERT_TO_GLOBALS then
***0         _G[funcname] = M[funcname]
***0         _G[alias] = M[funcname]
         end
     end

     ----------------------------------------------------------------
     --
     --                     Outputters
     --
     ----------------------------------------------------------------

     -- A common "base" class for outputters
     -- For concepts involved (class inheritance) see http://www.lua.org/pil/16.2.html

   1 local genericOutput = { __class__ = 'genericOutput' } -- class
   1 local genericOutput_MT = { __index = genericOutput } -- metatable
   1 M.genericOutput = genericOutput -- publish, so that custom classes may derive from it

   1 function genericOutput.new(runner, default_verbosity)
         -- runner is the "parent" object controlling the output, usually a LuaUnit instance
   4     local t = { runner = runner }
   4     if runner then
   1         t.result = runner.result
   1         t.verbosity = runner.verbosity or default_verbosity
   1         t.fname = runner.fname
         else
   3         t.verbosity = default_verbosity
         end
   4     return setmetatable( t, genericOutput_MT)
     end

     -- abstract ("empty") methods
   1 function genericOutput:startSuite() end
   2 function genericOutput:startClass(className) end
   1 function genericOutput:startTest(testName) end
   1 function genericOutput:addStatus(node) end
   1 function genericOutput:endTest(node) end
   2 function genericOutput:endClass() end
   1 function genericOutput:endSuite() end


     ----------------------------------------------------------------
     --                     class TapOutput
     ----------------------------------------------------------------

   1 local TapOutput = genericOutput.new() -- derived class
   1 local TapOutput_MT = { __index = TapOutput } -- metatable
   1 TapOutput.__class__ = 'TapOutput'

         -- For a good reference for TAP format, check: http://testanything.org/tap-specification.html

   1     function TapOutput.new(runner)
***0         local t = genericOutput.new(runner, M.VERBOSITY_LOW)
***0         return setmetatable( t, TapOutput_MT)
         end
   1     function TapOutput:startSuite()
***0         print("1.."..self.result.testCount)
***0         print('# Started on '..self.result.startDate)
         end
   1     function TapOutput:startClass(className)
***0         if className ~= '[TestFunctions]' then
***0             print('# Starting class: '..className)
             end
         end

   1     function TapOutput:addStatus( node )
***0         io.stdout:write("not ok ", self.result.currentTestNumber, "\t", node.testName, "\n")
***0         if self.verbosity > M.VERBOSITY_LOW then
***0            print( prefixString( '    ', node.msg ) )
             end
***0         if self.verbosity > M.VERBOSITY_DEFAULT then
***0            print( prefixString( '    ', node.stackTrace ) )
             end
         end

   1     function TapOutput:endTest( node )
***0         if node:isPassed() then
***0             io.stdout:write("ok     ", self.result.currentTestNumber, "\t", node.testName, "\n")
             end
         end

   1     function TapOutput:endSuite()
***0         print( '# '..M.LuaUnit.statusLine( self.result ) )
***0         return self.result.notPassedCount
         end


     -- class TapOutput end

     ----------------------------------------------------------------
     --                     class JUnitOutput
     ----------------------------------------------------------------

     -- See directory junitxml for more information about the junit format
   1 local JUnitOutput = genericOutput.new() -- derived class
   1 local JUnitOutput_MT = { __index = JUnitOutput } -- metatable
   1 JUnitOutput.__class__ = 'JUnitOutput'

   1     function JUnitOutput.new(runner)
***0         local t = genericOutput.new(runner, M.VERBOSITY_LOW)
***0         t.testList = {}
***0         return setmetatable( t, JUnitOutput_MT )
         end

   1     function JUnitOutput:startSuite()
             -- open xml file early to deal with errors
***0         if self.fname == nil then
***0             error('With Junit, an output filename must be supplied with --name!')
             end
***0         if string.sub(self.fname,-4) ~= '.xml' then
***0             self.fname = self.fname..'.xml'
             end
***0         self.fd = io.open(self.fname, "w")
***0         if self.fd == nil then
***0             error("Could not open file for writing: "..self.fname)
             end

***0         print('# XML output to '..self.fname)
***0         print('# Started on '..self.result.startDate)
         end
   1     function JUnitOutput:startClass(className)
***0         if className ~= '[TestFunctions]' then
***0             print('# Starting class: '..className)
             end
         end
   1     function JUnitOutput:startTest(testName)
***0         print('# Starting test: '..testName)
         end

   1     function JUnitOutput:addStatus( node )
***0         if node:isFailure() then
***0             print('# Failure: ' .. node.msg)
                 -- print('# ' .. node.stackTrace)
***0         elseif node:isError() then
***0             print('# Error: ' .. node.msg)
                 -- print('# ' .. node.stackTrace)
             end
         end

   1     function JUnitOutput:endSuite()
***0         print( '# '..M.LuaUnit.statusLine(self.result))

             -- XML file writing
***0         self.fd:write('<?xml version="1.0" encoding="UTF-8" ?>\n')
***0         self.fd:write('<testsuites>\n')
***0         self.fd:write(string.format(
                 '    <testsuite name="LuaUnit" id="00001" package="" hostname="localhost" tests="%d" timestamp="%s" time="%0.3f" errors="%d" failures="%d">\n',
***0             self.result.runCount, self.result.startIsodate, self.result.duration, self.result.errorCount, self.result.failureCount ))
***0         self.fd:write("        <properties>\n")
***0         self.fd:write(string.format('            <property name="Lua Version" value="%s"/>\n', _VERSION ) )
***0         self.fd:write(string.format('            <property name="LuaUnit Version" value="%s"/>\n', M.VERSION) )
             -- XXX please include system name and version if possible
***0         self.fd:write("        </properties>\n")

***0         for i,node in ipairs(self.result.tests) do
***0             self.fd:write(string.format('        <testcase classname="%s" name="%s" time="%0.3f">\n',
***0                 node.className, node.testName, node.duration ) )
***0             if node:isNotPassed() then
***0                 self.fd:write(node:statusXML())
                 end
***0             self.fd:write('        </testcase>\n')
             end

             -- Next two lines are needed to validate junit ANT xsd, but really not useful in general:
***0         self.fd:write('    <system-out/>\n')
***0         self.fd:write('    <system-err/>\n')

***0         self.fd:write('    </testsuite>\n')
***0         self.fd:write('</testsuites>\n')
***0         self.fd:close()
***0         return self.result.notPassedCount
         end


     -- class TapOutput end

     ----------------------------------------------------------------
     --                     class TextOutput
     ----------------------------------------------------------------

     --[[

     -- Python Non verbose:

     For each test: . or F or E

     If some failed tests:
         ==============
         ERROR / FAILURE: TestName (testfile.testclass)
         ---------
         Stack trace


     then --------------
     then "Ran x tests in 0.000s"
     then OK or FAILED (failures=1, error=1)

     -- Python Verbose:
     testname (filename.classname) ... ok
     testname (filename.classname) ... FAIL
     testname (filename.classname) ... ERROR

     then --------------
     then "Ran x tests in 0.000s"
     then OK or FAILED (failures=1, error=1)

     -- Ruby:
     Started
      .
      Finished in 0.002695 seconds.

      1 tests, 2 assertions, 0 failures, 0 errors

     -- Ruby:
     >> ruby tc_simple_number2.rb
     Loaded suite tc_simple_number2
     Started
     F..
     Finished in 0.038617 seconds.

       1) Failure:
     test_failure(TestSimpleNumber) [tc_simple_number2.rb:16]:
     Adding doesn't work.
     <3> expected but was
     <4>.

     3 tests, 4 assertions, 1 failures, 0 errors

     -- Java Junit
     .......F.
     Time: 0,003
     There was 1 failure:
     1) testCapacity(junit.samples.VectorTest)junit.framework.AssertionFailedError
         at junit.samples.VectorTest.testCapacity(VectorTest.java:87)
         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

     FAILURES!!!
     Tests run: 8,  Failures: 1,  Errors: 0


     -- Maven

     # mvn test
     -------------------------------------------------------
      T E S T S
     -------------------------------------------------------
     Running math.AdditionTest
     Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed:
     0.03 sec <<< FAILURE!

     Results :

     Failed tests:
       testLireSymbole(math.AdditionTest)

     Tests run: 2, Failures: 1, Errors: 0, Skipped: 0


     -- LuaUnit
     ---- non verbose
     * display . or F or E when running tests
     ---- verbose
     * display test name + ok/fail
     ----
     * blank line
     * number) ERROR or FAILURE: TestName
        Stack trace
     * blank line
     * number) ERROR or FAILURE: TestName
        Stack trace

     then --------------
     then "Ran x tests in 0.000s (%d not selected, %d skipped)"
     then OK or FAILED (failures=1, error=1)


     ]]

   1 local TextOutput = genericOutput.new() -- derived class
   1 local TextOutput_MT = { __index = TextOutput } -- metatable
   1 TextOutput.__class__ = 'TextOutput'

   1     function TextOutput.new(runner)
   1         local t = genericOutput.new(runner, M.VERBOSITY_DEFAULT)
   1         t.errorList = {}
   1         return setmetatable( t, TextOutput_MT )
         end

   1     function TextOutput:startSuite()
   1         if self.verbosity > M.VERBOSITY_DEFAULT then
   1             print( 'Started on '.. self.result.startDate )
             end
         end

   1     function TextOutput:startTest(testName)
  85         if self.verbosity > M.VERBOSITY_DEFAULT then
  85             io.stdout:write( "    ", self.result.currentNode.testName, " ... " )
             end
         end

   1     function TextOutput:endTest( node )
  85         if node:isPassed() then
  85             if self.verbosity > M.VERBOSITY_DEFAULT then
  85                 io.stdout:write("Ok\n")
                 else
***0                 io.stdout:write(".")
                 end
             else
***0             if self.verbosity > M.VERBOSITY_DEFAULT then
***0                 print( node.status )
***0                 print( node.msg )
                     --[[
                     -- find out when to do this:
                     if self.verbosity > M.VERBOSITY_DEFAULT then
                         print( node.stackTrace )
                     end
                     ]]
                 else
                     -- write only the first character of status
***0                 io.stdout:write(string.sub(node.status, 1, 1))
                 end
             end
         end

   1     function TextOutput:displayOneFailedTest( index, fail )
***0         print(index..") "..fail.testName )
***0         print( fail.msg )
***0         print( fail.stackTrace )
***0         print()
         end

   1     function TextOutput:displayFailedTests()
   1         if self.result.notPassedCount ~= 0 then
***0             print("Failed tests:")
***0             print("-------------")
***0             for i, v in ipairs(self.result.notPassed) do
***0                 self:displayOneFailedTest(i, v)
                 end
             end
         end

   1     function TextOutput:endSuite()
   1         if self.verbosity > M.VERBOSITY_DEFAULT then
   1             print("=========================================================")
             else
***0             print()
             end
   1         self:displayFailedTests()
   1         print( M.LuaUnit.statusLine( self.result ) )
   1         if self.result.notPassedCount == 0 then
   1             print('OK')
             end
         end

     -- class TextOutput end


     ----------------------------------------------------------------
     --                     class NilOutput
     ----------------------------------------------------------------

     local function nopCallable()
         --print(42)
***0     return nopCallable
     end

   1 local NilOutput = { __class__ = 'NilOuptut' } -- class
   1 local NilOutput_MT = { __index = nopCallable } -- metatable

   1 function NilOutput.new(runner)
***0     return setmetatable( { __class__ = 'NilOutput' }, NilOutput_MT )
     end

     ----------------------------------------------------------------
     --
     --                     class LuaUnit
     --
     ----------------------------------------------------------------

   1 M.LuaUnit = {
   1     outputType = TextOutput,
   1     verbosity = M.VERBOSITY_DEFAULT,
   1     __class__ = 'LuaUnit'
   1 }
   1 local LuaUnit_MT = { __index = M.LuaUnit }

   1 if EXPORT_ASSERT_TO_GLOBALS then
***0     LuaUnit = M.LuaUnit
     end

   2     function M.LuaUnit.new()
   1         return setmetatable( {}, LuaUnit_MT )
         end

         -----------------[[ Utility methods ]]---------------------

   2     function M.LuaUnit.asFunction(aObject)
             -- return "aObject" if it is a function, and nil otherwise
 851         if 'function' == type(aObject) then
  85             return aObject
             end
         end

   2     function M.LuaUnit.splitClassMethod(someName)
             --[[
             Return a pair of className, methodName strings for a name in the form
             "class.method". If no class part (or separator) is found, will return
             nil, someName instead (the latter being unchanged).

             This convention thus also replaces the older isClassMethod() test:
             You just have to check for a non-nil className (return) value.
             ]]
  87         local separator = string.find(someName, '.', 1, true)
  87         if separator then
  85             return someName:sub(1, separator - 1), someName:sub(separator + 1)
             end
   2         return nil, someName
         end

   2     function M.LuaUnit.isMethodTestName( s )
             -- return true is the name matches the name of a test method
             -- default rule is that is starts with 'Test' or with 'test'
  85         return string.sub(s, 1, 4):lower() == 'test'
         end

   2     function M.LuaUnit.isTestName( s )
             -- return true is the name matches the name of a test
             -- default rule is that is starts with 'Test' or with 'test'
 316         return string.sub(s, 1, 4):lower() == 'test'
         end

   2     function M.LuaUnit.collectTests()
             -- return a list of all test names in the global namespace
             -- that match LuaUnit.isTestName

   1         local testNames = {}
 317         for k, _ in pairs(_G) do
 316             if type(k) == "string" and M.LuaUnit.isTestName( k ) then
   1                 table.insert( testNames , k )
                 end
             end
   1         table.sort( testNames )
   1         return testNames
         end

   2     function M.LuaUnit.parseCmdLine( cmdLine )
             -- parse the command line
             -- Supported command line parameters:
             -- --verbose, -v: increase verbosity
             -- --quiet, -q: silence output
             -- --error, -e: treat errors as fatal (quit program)
             -- --output, -o, + name: select output type
             -- --pattern, -p, + pattern: run test matching pattern, may be repeated
             -- --exclude, -x, + pattern: run test not matching pattern, may be repeated
             -- --random, -r, : run tests in random order
             -- --name, -n, + fname: name of output file for junit, default to stdout
             -- --count, -c, + num: number of times to execute each test
             -- [testnames, ...]: run selected test names
             --
             -- Returns a table with the following fields:
             -- verbosity: nil, M.VERBOSITY_DEFAULT, M.VERBOSITY_QUIET, M.VERBOSITY_VERBOSE
             -- output: nil, 'tap', 'junit', 'text', 'nil'
             -- testNames: nil or a list of test names to run
             -- exeCount: num or 1
             -- pattern: nil or a list of patterns
             -- exclude: nil or a list of patterns

   1         local result, state = {}, nil
   1         local SET_OUTPUT = 1
   1         local SET_PATTERN = 2
   1         local SET_EXCLUDE = 3
   1         local SET_FNAME = 4
   1         local SET_XCOUNT = 5

   1         if cmdLine == nil then
***0             return result
             end

             local function parseOption( option )
   1             if option == '--help' or option == '-h' then
***0                 result['help'] = true
***0                 return
   1             elseif option == '--version' then
***0                 result['version'] = true
***0                 return
   1             elseif option == '--verbose' or option == '-v' then
   1                 result['verbosity'] = M.VERBOSITY_VERBOSE
   1                 return
***0             elseif option == '--quiet' or option == '-q' then
***0                 result['verbosity'] = M.VERBOSITY_QUIET
***0                 return
***0             elseif option == '--error' or option == '-e' then
***0                 result['quitOnError'] = true
***0                 return
***0             elseif option == '--failure' or option == '-f' then
***0                 result['quitOnFailure'] = true
***0                 return
***0             elseif option == '--random' or option == '-r' then
***0                 result['randomize'] = true
***0                 return
***0             elseif option == '--output' or option == '-o' then
***0                 state = SET_OUTPUT
***0                 return state
***0             elseif option == '--name' or option == '-n' then
***0                 state = SET_FNAME
***0                 return state
***0             elseif option == '--count' or option == '-c' then
***0                 state = SET_XCOUNT
***0                 return state
***0             elseif option == '--pattern' or option == '-p' then
***0                 state = SET_PATTERN
***0                 return state
***0             elseif option == '--exclude' or option == '-x' then
***0                 state = SET_EXCLUDE
***0                 return state
                 end
***0             error('Unknown option: '..option,3)
             end

             local function setArg( cmdArg, state )
***0             if state == SET_OUTPUT then
***0                 result['output'] = cmdArg
***0                 return
***0             elseif state == SET_FNAME then
***0                 result['fname'] = cmdArg
***0                 return
***0             elseif state == SET_XCOUNT then
***0                 result['exeCount'] = tonumber(cmdArg)
***0                                      or error('Malformed -c argument: '..cmdArg)
***0                 return
***0             elseif state == SET_PATTERN then
***0                 if result['pattern'] then
***0                     table.insert( result['pattern'], cmdArg )
                     else
***0                     result['pattern'] = { cmdArg }
                     end
***0                 return
***0             elseif state == SET_EXCLUDE then
***0                 local notArg = '!'..cmdArg
***0                 if result['pattern'] then
***0                     table.insert( result['pattern'],  notArg )
                     else
***0                     result['pattern'] = { notArg }
                     end
***0                 return
                 end
***0             error('Unknown parse state: '.. state)
             end


   2         for i, cmdArg in ipairs(cmdLine) do
   1             if state ~= nil then
***0                 setArg( cmdArg, state, result )
***0                 state = nil
                 else
   1                 if cmdArg:sub(1,1) == '-' then
   1                     state = parseOption( cmdArg )
                     else
***0                     if result['testNames'] then
***0                         table.insert( result['testNames'], cmdArg )
                         else
***0                         result['testNames'] = { cmdArg }
                         end
                     end
                 end
             end

   1         if result['help'] then
***0             M.LuaUnit.help()
             end

   1         if result['version'] then
***0             M.LuaUnit.version()
             end

   1         if state ~= nil then
***0             error('Missing argument after '..cmdLine[ #cmdLine ],2 )
             end

   1         return result
         end

   2     function M.LuaUnit.help()
***0         print(M.USAGE)
***0         os.exit(0)
         end

   2     function M.LuaUnit.version()
***0         print('LuaUnit v'..M.VERSION..' by Philippe Fremy <phil@freehackers.org>')
***0         os.exit(0)
         end

     ----------------------------------------------------------------
     --                     class NodeStatus
     ----------------------------------------------------------------

   1     local NodeStatus = { __class__ = 'NodeStatus' } -- class
   1     local NodeStatus_MT = { __index = NodeStatus } -- metatable
   1     M.NodeStatus = NodeStatus

         -- values of status
   1     NodeStatus.PASS  = 'PASS'
   1     NodeStatus.FAIL  = 'FAIL'
   1     NodeStatus.ERROR = 'ERROR'

   1     function NodeStatus.new( number, testName, className )
  85         local t = { number = number, testName = testName, className = className }
  85         setmetatable( t, NodeStatus_MT )
  85         t:pass()
  85         return t
         end

   2     function NodeStatus:pass()
  85         self.status = self.PASS
             -- useless but we know it's the field we want to use
  85         self.msg = nil
  85         self.stackTrace = nil
         end

   2     function NodeStatus:fail(msg, stackTrace)
***0         self.status = self.FAIL
***0         self.msg = msg
***0         self.stackTrace = stackTrace
         end

   1     function NodeStatus:error(msg, stackTrace)
***0         self.status = self.ERROR
***0         self.msg = msg
***0         self.stackTrace = stackTrace
         end

   2     function NodeStatus:isPassed()
 255         return self.status == NodeStatus.PASS
         end

   2     function NodeStatus:isNotPassed()
             -- print('hasFailure: '..prettystr(self))
  85         return self.status ~= NodeStatus.PASS
         end

   2     function NodeStatus:isFailure()
***0         return self.status == NodeStatus.FAIL
         end

   2     function NodeStatus:isError()
***0         return self.status == NodeStatus.ERROR
         end

   2     function NodeStatus:statusXML()
***0         if self:isError() then
***0             return table.concat(
***0                 {'            <error type="', xmlEscape(self.msg), '">\n',
***0                  '                <![CDATA[', xmlCDataEscape(self.stackTrace),
                      ']]></error>\n'})
***0         elseif self:isFailure() then
***0             return table.concat(
***0                 {'            <failure type="', xmlEscape(self.msg), '">\n',
***0                  '                <![CDATA[', xmlCDataEscape(self.stackTrace),
                      ']]></failure>\n'})
             end
***0         return '            <passed/>\n' -- (not XSD-compliant! normally shouldn't get here)
         end

         --------------[[ Output methods ]]-------------------------

         local function conditional_plural(number, singular)
             -- returns a grammatically well-formed string "%d <singular/plural>"
   1         local suffix = ''
   1         if number ~= 1 then -- use plural
   1             suffix = (singular:sub(-2) == 'ss') and 'es' or 's'
             end
   1         return string.format('%d %s%s', number, singular, suffix)
         end

   2     function M.LuaUnit.statusLine(result)
             -- return status line string according to results
   1         local s = {
   2             string.format('Ran %d tests in %0.3f seconds',
   1                           result.runCount, result.duration),
   1             conditional_plural(result.passedCount, 'success'),
   1         }
   1         if result.notPassedCount > 0 then
***0             if result.failureCount > 0 then
***0                 table.insert(s, conditional_plural(result.failureCount, 'failure'))
                 end
***0             if result.errorCount > 0 then
***0                 table.insert(s, conditional_plural(result.errorCount, 'error'))
                 end
             else
   1             table.insert(s, '0 failures')
             end
   1         if result.nonSelectedCount > 0 then
***0             table.insert(s, string.format("%d non-selected", result.nonSelectedCount))
             end
   1         return table.concat(s, ', ')
         end

   2     function M.LuaUnit:startSuite(testCount, nonSelectedCount)
   1         self.result = {
   1             testCount = testCount,
   1             nonSelectedCount = nonSelectedCount,
   1             passedCount = 0,
   1             runCount = 0,
   1             currentTestNumber = 0,
   1             currentClassName = "",
   1             currentNode = nil,
   1             suiteStarted = true,
   1             startTime = os.clock(),
   1             startDate = os.date(os.getenv('LUAUNIT_DATEFMT')),
   1             startIsodate = os.date('%Y-%m-%dT%H:%M:%S'),
   1             patternIncludeFilter = self.patternIncludeFilter,
   1             tests = {},
   1             failures = {},
   1             errors = {},
   1             notPassed = {},
   1         }

   1         self.outputType = self.outputType or TextOutput
   1         self.output = self.outputType.new(self)
   1         self.output:startSuite()
         end

   2     function M.LuaUnit:startClass( className )
   1         self.result.currentClassName = className
   1         self.output:startClass( className )
         end

   2     function M.LuaUnit:startTest( testName  )
  85         self.result.currentTestNumber = self.result.currentTestNumber + 1
  85         self.result.runCount = self.result.runCount + 1
 170         self.result.currentNode = NodeStatus.new(
  85             self.result.currentTestNumber,
  85             testName,
  85             self.result.currentClassName
 170         )
  85         self.result.currentNode.startTime = os.clock()
  85         table.insert( self.result.tests, self.result.currentNode )
  85         self.output:startTest( testName )
         end

   2     function M.LuaUnit:addStatus( err )
             -- "err" is expected to be a table / result from protectedCall()
  85         if err.status == NodeStatus.PASS then
  85             return
             end

***0         local node = self.result.currentNode

             --[[ As a first approach, we will report only one error or one failure for one test.

             However, we can have the case where the test is in failure, and the teardown is in error.
             In such case, it's a good idea to report both a failure and an error in the test suite. This is
             what Python unittest does for example. However, it mixes up counts so need to be handled carefully: for
             example, there could be more (failures + errors) count that tests. What happens to the current node ?

             We will do this more intelligent version later.
             ]]

             -- if the node is already in failure/error, just don't report the new error (see above)
***0         if node.status ~= NodeStatus.PASS then
***0             return
             end

***0         if err.status == NodeStatus.FAIL then
***0             node:fail( err.msg, err.trace )
***0             table.insert( self.result.failures, node )
***0         elseif err.status == NodeStatus.ERROR then
***0             node:error( err.msg, err.trace )
***0             table.insert( self.result.errors, node )
             end

***0         if node:isFailure() or node:isError() then
                 -- add to the list of failed tests (gets printed separately)
***0             table.insert( self.result.notPassed, node )
             end
***0         self.output:addStatus( node )
         end

   2     function M.LuaUnit:endTest()
  85         local node = self.result.currentNode
             -- print( 'endTest() '..prettystr(node))
             -- print( 'endTest() '..prettystr(node:isNotPassed()))
  85         node.duration = os.clock() - node.startTime
  85         node.startTime = nil
  85         self.output:endTest( node )

  85         if node:isPassed() then
  85             self.result.passedCount = self.result.passedCount + 1
***0         elseif node:isError() then
***0             if self.quitOnError or self.quitOnFailure then
                     -- Runtime error - abort test execution as requested by
                     -- "--error" option. This is done by setting a special
                     -- flag that gets handled in runSuiteByInstances().
***0                 print("\nERROR during LuaUnit test execution:\n" .. node.msg)
***0                 self.result.aborted = true
                 end
***0         elseif node:isFailure() then
***0             if self.quitOnFailure then
                     -- Failure - abort test execution as requested by
                     -- "--failure" option. This is done by setting a special
                     -- flag that gets handled in runSuiteByInstances().
***0                 print("\nFailure during LuaUnit test execution:\n" .. node.msg)
***0                 self.result.aborted = true
                 end
             end
  85         self.result.currentNode = nil
         end

   2     function M.LuaUnit:endClass()
   1         self.output:endClass()
         end

   2     function M.LuaUnit:endSuite()
   1         if self.result.suiteStarted == false then
***0             error('LuaUnit:endSuite() -- suite was already ended' )
             end
   1         self.result.duration = os.clock()-self.result.startTime
   1         self.result.suiteStarted = false

             -- Expose test counts for outputter's endSuite(). This could be managed
             -- internally instead, but unit tests (and existing use cases) might
             -- rely on these fields being present.
   1         self.result.notPassedCount = #self.result.notPassed
   1         self.result.failureCount = #self.result.failures
   1         self.result.errorCount = #self.result.errors

   1         self.output:endSuite()
         end

   2     function M.LuaUnit:setOutputType(outputType)
             -- default to text
             -- tap produces results according to TAP format
***0         if outputType:upper() == "NIL" then
***0             self.outputType = NilOutput
***0             return
             end
***0         if outputType:upper() == "TAP" then
***0             self.outputType = TapOutput
***0             return
             end
***0         if outputType:upper() == "JUNIT" then
***0             self.outputType = JUnitOutput
***0             return
             end
***0         if outputType:upper() == "TEXT" then
***0             self.outputType = TextOutput
***0             return
             end
***0         error( 'No such format: '..outputType,2)
         end

         --------------[[ Runner ]]-----------------

   2     function M.LuaUnit:protectedCall(classInstance, methodInstance, prettyFuncName)
             -- if classInstance is nil, this is just a function call
             -- else, it's method of a class being called.

             local function err_handler(e)
                 -- transform error into a table, adding the traceback information
***0             return {
                     status = NodeStatus.ERROR,
                     msg = e,
***0                 trace = string.sub(debug.traceback("", 3), 2)
                 }
             end

             local ok, err
  85         if classInstance then
                 -- stupid Lua < 5.2 does not allow xpcall with arguments so let's use a workaround
 170             ok, err = xpcall( function () methodInstance(classInstance) end, err_handler )
             else
***0             ok, err = xpcall( function () methodInstance() end, err_handler )
             end
  85         if ok then
  85             return {status = NodeStatus.PASS}
             end

             -- determine if the error was a failed test:
             -- We do this by stripping the failure prefix from the error message,
             -- while keeping track of the gsub() count. A non-zero value -> failure
             local failed, iter_msg
***0         iter_msg = self.exeCount and 'iteration: '..self.currentCount..', '
***0         err.msg, failed = err.msg:gsub(M.FAILURE_PREFIX, iter_msg or '', 1)
***0         if failed > 0 then
***0             err.status = NodeStatus.FAIL
             end

             -- reformat / improve the stack trace
***0         if prettyFuncName then -- we do have the real method name
***0             err.trace = err.trace:gsub("in (%a+) 'methodInstance'", "in %1 '"..prettyFuncName.."'")
             end
***0         if STRIP_LUAUNIT_FROM_STACKTRACE then
***0             err.trace = stripLuaunitTrace(err.trace)
             end

***0         return err -- return the error "object" (table)
         end


   2     function M.LuaUnit:execOneFunction(className, methodName, classInstance, methodInstance)
             -- When executing a test function, className and classInstance must be nil
             -- When executing a class method, all parameters must be set

  85         if type(methodInstance) ~= 'function' then
***0             error( tostring(methodName)..' must be a function, not '..type(methodInstance))
             end

             local prettyFuncName
  85         if className == nil then
***0             className = '[TestFunctions]'
***0             prettyFuncName = methodName
             else
  85             prettyFuncName = className..'.'..methodName
             end

  85         if self.lastClassName ~= className then
   1             if self.lastClassName ~= nil then
***0                 self:endClass()
                 end
   1             self:startClass( className )
   1             self.lastClassName = className
             end

  85         self:startTest(prettyFuncName)

  85         local node = self.result.currentNode
 170         for iter_n = 1, self.exeCount or 1 do
  85             if node:isNotPassed() then
                     break
                 end
  85             self.currentCount = iter_n

                 -- run setUp first (if any)
  85             if classInstance then
  85                 local func = self.asFunction( classInstance.setUp ) or
  85                              self.asFunction( classInstance.Setup ) or
  85                              self.asFunction( classInstance.setup ) or
  85                              self.asFunction( classInstance.SetUp )
  85                 if func then
***0                     self:addStatus(self:protectedCall(classInstance, func, className..'.setUp'))
                     end
                 end

                 -- run testMethod()
  85             if node:isPassed() then
  85                 self:addStatus(self:protectedCall(classInstance, methodInstance, prettyFuncName))
                 end

                 -- lastly, run tearDown (if any)
  85             if classInstance then
  85                 local func = self.asFunction( classInstance.tearDown ) or
  85                              self.asFunction( classInstance.TearDown ) or
  85                              self.asFunction( classInstance.teardown ) or
  85                              self.asFunction( classInstance.Teardown )
  85                 if func then
***0                     self:addStatus(self:protectedCall(classInstance, func, className..'.tearDown'))
                     end
                 end
             end

  85         self:endTest()
         end

   2     function M.LuaUnit.expandOneClass( result, className, classInstance )
             --[[
             Input: a list of { name, instance }, a class name, a class instance
             Ouptut: modify result to add all test method instance in the form:
             { className.methodName, classInstance }
             ]]
  86         for methodName, methodInstance in sortedPairs(classInstance) do
  85             if M.LuaUnit.asFunction(methodInstance) and M.LuaUnit.isMethodTestName( methodName ) then
  85                 table.insert( result, { className..'.'..methodName, classInstance } )
                 end
             end
         end

   2     function M.LuaUnit.expandClasses( listOfNameAndInst )
             --[[
             -- expand all classes (provided as {className, classInstance}) to a list of {className.methodName, classInstance}
             -- functions and methods remain untouched

             Input: a list of { name, instance }

             Output:
             * { function name, function instance } : do nothing
             * { class.method name, class instance }: do nothing
             * { class name, class instance } : add all method names in the form of (className.methodName, classInstance)
             ]]
   1         local result = {}

   2         for i,v in ipairs( listOfNameAndInst ) do
   1             local name, instance = v[1], v[2]
   1             if M.LuaUnit.asFunction(instance) then
***0                 table.insert( result, { name, instance } )
                 else
   1                 if type(instance) ~= 'table' then
***0                     error( 'Instance must be a table or a function, not a '..type(instance)..', value '..prettystr(instance))
                     end
   1                 local className, methodName = M.LuaUnit.splitClassMethod( name )
   1                 if className then
***0                     local methodInstance = instance[methodName]
***0                     if methodInstance == nil then
***0                         error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                         end
***0                     table.insert( result, { name, instance } )
                     else
   1                     M.LuaUnit.expandOneClass( result, name, instance )
                     end
                 end
             end

   1         return result
         end

   2     function M.LuaUnit.applyPatternFilter( patternIncFilter, listOfNameAndInst )
   1         local included, excluded = {}, {}
  86         for i, v in ipairs( listOfNameAndInst ) do
                 -- local name, instance = v[1], v[2]
  85             if  patternFilter( patternIncFilter, v[1], true ) then
  85                 table.insert( included, v )
                 else
***0                 table.insert( excluded, v )
                 end
             end
   1         return included, excluded
         end

   2     function M.LuaUnit:runSuiteByInstances( listOfNameAndInst )
             --[[ Run an explicit list of tests. All test instances and names must be supplied.
             each test must be one of:
             * { function name, function instance }
             * { class name, class instance }
             * { class.method name, class instance }
             ]]

   1         local expandedList = self.expandClasses( listOfNameAndInst )
   1         if self.randomize then
***0             randomizeTable( expandedList )
             end
   2         local filteredList, filteredOutList = self.applyPatternFilter(
   1             self.patternIncludeFilter, expandedList )

   1         self:startSuite( #filteredList, #filteredOutList )

  86         for i,v in ipairs( filteredList ) do
  85             local name, instance = v[1], v[2]
  85             if M.LuaUnit.asFunction(instance) then
***0                 self:execOneFunction( nil, name, nil, instance )
                 else
                     -- expandClasses() should have already taken care of sanitizing the input
  85                 assert( type(instance) == 'table' )
  85                 local className, methodName = M.LuaUnit.splitClassMethod( name )
  85                 assert( className ~= nil )
  85                 local methodInstance = instance[methodName]
  85                 assert(methodInstance ~= nil)
  85                 self:execOneFunction( className, methodName, instance, methodInstance )
                 end
  85             if self.result.aborted then
                     break -- "--error" or "--failure" option triggered
                 end
             end

   1         if self.lastClassName ~= nil then
   1             self:endClass()
             end

   1         self:endSuite()

   1         if self.result.aborted then
***0             print("LuaUnit ABORTED (as requested by --error or --failure option)")
***0             os.exit(-2)
             end
         end

   2     function M.LuaUnit:runSuiteByNames( listOfName )
             --[[ Run LuaUnit with a list of generic names, coming either from command-line or from global
                 namespace analysis. Convert the list into a list of (name, valid instances (table or function))
                 and calls runSuiteByInstances.
             ]]

             local instanceName, instance
   1         local listOfNameAndInst = {}

   2         for i,name in ipairs( listOfName ) do
   1             local className, methodName = M.LuaUnit.splitClassMethod( name )
   1             if className then
***0                 instanceName = className
***0                 instance = _G[instanceName]

***0                 if instance == nil then
***0                     error( "No such name in global space: "..instanceName )
                     end

***0                 if type(instance) ~= 'table' then
***0                     error( 'Instance of '..instanceName..' must be a table, not '..type(instance))
                     end

***0                 local methodInstance = instance[methodName]
***0                 if methodInstance == nil then
***0                     error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                     end

                 else
                     -- for functions and classes
   1                 instanceName = name
   1                 instance = _G[instanceName]
                 end

   1             if instance == nil then
***0                 error( "No such name in global space: "..instanceName )
                 end

   1             if (type(instance) ~= 'table' and type(instance) ~= 'function') then
***0                 error( 'Name must match a function or a table: '..instanceName )
                 end

   1             table.insert( listOfNameAndInst, { name, instance } )
             end

   1         self:runSuiteByInstances( listOfNameAndInst )
         end

   2     function M.LuaUnit.run(...)
             -- Run some specific test classes.
             -- If no arguments are passed, run the class names specified on the
             -- command line. If no class name is specified on the command line
             -- run all classes whose name starts with 'Test'
             --
             -- If arguments are passed, they must be strings of the class names
             -- that you want to run or generic command line arguments (-o, -p, -v, ...)

***0         local runner = M.LuaUnit.new()
***0         return runner:runSuite(...)
         end

   2     function M.LuaUnit:runSuite( ... )

   1         local args = {...}
   1         if type(args[1]) == 'table' and args[1].__class__ == 'LuaUnit' then
                 -- run was called with the syntax M.LuaUnit:runSuite()
                 -- we support both M.LuaUnit.run() and M.LuaUnit:run()
                 -- strip out the first argument
***0             table.remove(args,1)
             end

   1         if #args == 0 then
***0             args = cmdline_argv
             end

   1         local options = pcall_or_abort( M.LuaUnit.parseCmdLine, args )

             -- We expect these option fields to be either `nil` or contain
             -- valid values, so it's safe to always copy them directly.
   1         self.verbosity     = options.verbosity
   1         self.quitOnError   = options.quitOnError
   1         self.quitOnFailure = options.quitOnFailure
   1         self.fname         = options.fname

   1         self.exeCount             = options.exeCount
   1         self.patternIncludeFilter = options.pattern
   1         self.randomize     = options.randomize

   1         if options.output then
***0             if options.output:lower() == 'junit' and options.fname == nil then
***0                 print('With junit output, a filename must be supplied with -n or --name')
***0                 os.exit(-1)
                 end
***0             pcall_or_abort(self.setOutputType, self, options.output)
             end

   1         self:runSuiteByNames( options.testNames or M.LuaUnit.collectTests() )

   1         return self.result.notPassedCount
         end
     -- class LuaUnit

     -- For compatbility with LuaUnit v2
   1 M.run = M.LuaUnit.run
   1 M.Run = M.LuaUnit.run

   2 function M:setVerbosity( verbosity )
***0     M.LuaUnit.verbosity = verbosity
     end
   1 M.set_verbosity = M.setVerbosity
   1 M.SetVerbosity = M.setVerbosity


   1 return M

==============================================================================
C:/ProgramData/zpm/bootstrap/test/tests.lua
==============================================================================
     --[[ @cond ___LICENSE___
     -- Copyright (c) 2017 Zefiros Software.
     --
     -- Permission is hereby granted, free of charge, to any person obtaining a copy
     -- of this software and associated documentation files (the "Software"), to deal
     -- in the Software without restriction, including without limitation the rights
     -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     -- copies of the Software, and to permit persons to whom the Software is
     -- furnished to do so, subject to the following conditions:
     --
     -- The above copyright notice and this permission notice shall be included in
     -- all copies or substantial portions of the Software.
     --
     -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     -- THE SOFTWARE.
     --
     -- @endcond
     --]]

     -- Libraries
***0 local u = require "extern.luaunit"
     require "extern.luacov"

   1 require( "bootstrap" )

     -- Mocking

     -- Load environment
   1 dofile( "action/test.lua" )

   1 TestBootstrap = {} 
   2 function TestBootstrap:testBootstrapExists()
   1     u.assertNotEquals( bootstrap, nil )
   1     u.assertIsTable( bootstrap )
     end

   2 function TestBootstrap:testSemverExists()
   1     u.assertNotEquals( bootstrap.semver, nil )
     end

   2 function TestBootstrap:testSemver()
   1     u.assertEquals( bootstrap.semver( '2.5.1' ), bootstrap.semver( 2, 5, 1 ) )
     end

   2 function TestBootstrap:testCorrectVersion()
   1     bootstrap.semver( bootstrap._VERSION )
   1     u.assertIsString( bootstrap._VERSION )
     end

   2 function TestBootstrap:testDirModules()
   1     u.assertIsNil( bootstrap._dirModules )
     end

   2 function TestBootstrap:testDirectories()
   1     u.assertIsTable( bootstrap.directories )
         
   3     for _, dir in pairs( bootstrap.directories ) do
   2         u.assertIsString( dir )		
         end
         
     end

   2 function TestBootstrap:testInit()

   1     u.assertFalse( os.isdir( "modules-test" ) ) 
         
   1     bootstrap.init( "modules-test" )
         
   1     u.assertTrue( os.isdir( "modules-test" ) ) 
         
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
     end

   2 function TestBootstrap:testInit_CantMake()

         -- linux and osx are more lenient
   1     if os.get() == "Windows" then
***0         u.assertFalse( os.isdir( "modules<'''>test" ) ) 

***0         u.assertErrorMsgContains( "unable to create directory", bootstrap.init, "modules<'''>test" )
                     
***0         u.assertFalse( os.isdir( "modules<'''>test" ) ) 
         end
     end

   2 function TestBootstrap:testGetModule()

   1     u.assertItemsEquals( bootstrap.getModule( "Zefiros-Software/zpm" ), { "Zefiros-Software", "zpm" } ) 
   1     u.assertItemsEquals( bootstrap.getModule( "Zefiros-Software/zpm-zpm" ), { "Zefiros-Software", "zpm-zpm" } ) 
   1     u.assertItemsEquals( bootstrap.getModule( "Zefiros-Software/zpm_zpm" ), { "Zefiros-Software", "zpm_zpm" } ) 
   1     u.assertItemsEquals( bootstrap.getModule( "Zefiros-Software" ), { "Zefiros-Software" } ) 
   1     u.assertItemsEquals( bootstrap.getModule( "Zefiros_Software" ), { "Zefiros_Software" } ) 
   1     u.assertItemsEquals( bootstrap.getModule( "zpm" ), { "zpm" } ) 

     end

   2 function TestBootstrap:testGetModule_Empty()
   1     u.assertErrorMsgContains( "Given module may not be empty ''!", bootstrap.getModule, "" )

     end

   2 function TestBootstrap:testGetModule_AlphanumericVendor()
   1     u.assertErrorMsgContains( "Vendor name 'Zefiros-Software$' must be alphanumeric!", bootstrap.getModule, "Zefiros-Software$/zpm" )
   1     u.assertErrorMsgContains( "Module name 'zpm%zpm' must be alphanumeric!", bootstrap.getModule, "Zefiros-Software/zpm%zpm" )
   1     u.assertErrorMsgContains( "Vendor name 'Zefiros-Software$' must be alphanumeric!", bootstrap.getModule, "Zefiros-Software$/zpm%zpm" )
   1     u.assertErrorMsgContains( "Vendor name may not be empty!", bootstrap.getModule, "/zpm" )
   1     u.assertErrorMsgContains( "Module name may not be empty!", bootstrap.getModule, "zpm/" )
                 
     end

   2 function TestBootstrap:testListModulesTags_NoInit()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm2/2.0.0",
             
   1         "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1         "modules-test/Zefiros-Softwarefe/df/0.3.1", 
             "modules-test/Zefiros-Softwarefe/df/3.4.0" 
   1     }
         
  10     for _, dir in ipairs( dirs ) do
             
   9         assert( os.mkdir( dir ) )
   9         u.assertTrue( os.isdir( dir ) )
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesTags()
   1     u.assertEquals( #tags, 0 )
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesTags_Init()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/azpm2/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/azpm2/0.0.1", 
   1         "modules-test/Zefiros-Software/azpm2/2.0.0",
             
   1         "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1         "modules-test/Zefiros-Softwarefe/df/0.3.1", 
             "modules-test/Zefiros-Softwarefe/df/3.4.0"
   1     }
         
  10     for _, dir in ipairs( dirs ) do
             
   9         u.assertFalse( os.isdir( dir ) )
   9         assert( os.mkdir( dir ) )
   9         u.assertTrue( os.isdir( dir ) )
             
   9         local file = io.open( dir .. "/init.lua", "w" )
   9         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesTags()
   1     u.assertEquals( #tags, 9 )
   2     u.assertItemsEquals( tags, {			
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/3.4.0/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/3.4.0",
   1             version = "3.4.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/1.5.4-ga/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1             version = "1.5.4-ga"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/0.3.1/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/0.3.1", 
   1             version = "0.3.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/azpm2/2.0.0/init",
   1             path = "modules-test/Zefiros-Software/azpm2/2.0.0",
   1             version = "2.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/azpm2/1.0.0-beta/init",
   1             path = "modules-test/Zefiros-Software/azpm2/1.0.0-beta", 
   1             version = "1.0.0-beta"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/azpm2/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/azpm2/0.0.1", 
   1             version = "0.0.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/3.0.0/init",
   1             path = "modules-test/Zefiros-Software/zpm/3.0.0",
   1             version = "3.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/1.0.0-alpha/init",
   1             path = "modules-test/Zefiros-Software/zpm/1.0.0-alpha",
   1             version = "1.0.0-alpha"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/zpm/0.0.1",
   1             version = "0.0.1"
             }
   1     } ) 
         
         -- cleanup
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesTags_InitModule()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/zpm/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm/0.0.2", 
   1         "modules-test/Zefiros-Software/zpm/2.0.0",
             
   1         "modules-test/Zefiros-Softwarefe/zpm/1.5.4-ga", 
   1         "modules-test/Zefiros-Softwarefe/zpm/0.3.1", 
             "modules-test/Zefiros-Softwarefe/zpm/3.4.0"
   1     }
         
  10     for _, dir in ipairs( dirs ) do
             
   9         u.assertFalse( os.isdir( dir ) )
   9         assert( os.mkdir( dir ) )
   9         u.assertTrue( os.isdir( dir ) )
             
   9         local file = io.open( dir .. "/zpm.lua", "w" )
   9         file:close()
         end
         
         -- test
   1     local tags = bootstrap.listModulesTags()
   1     u.assertEquals( #tags, 9 )
   2     u.assertItemsEquals( tags, {			
             {
   1             loader = "modules-test/Zefiros-Softwarefe/zpm/3.4.0/zpm",
   1             path = "modules-test/Zefiros-Softwarefe/zpm/3.4.0",
   1             version = "3.4.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/zpm/1.5.4-ga/zpm",
   1             path = "modules-test/Zefiros-Softwarefe/zpm/1.5.4-ga", 
   1             version = "1.5.4-ga"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/zpm/0.3.1/zpm",
   1             path = "modules-test/Zefiros-Softwarefe/zpm/0.3.1", 
   1             version = "0.3.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/3.0.0/zpm",
   1             path = "modules-test/Zefiros-Software/zpm/3.0.0",
   1             version = "3.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/2.0.0/zpm",
   1             path = "modules-test/Zefiros-Software/zpm/2.0.0",
   1             version = "2.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/1.0.0-beta/zpm",
   1             path = "modules-test/Zefiros-Software/zpm/1.0.0-beta", 
   1             version = "1.0.0-beta"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/1.0.0-alpha/zpm",
   1             path = "modules-test/Zefiros-Software/zpm/1.0.0-alpha",
   1             version = "1.0.0-alpha"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/0.0.2/zpm",
   1             path = "modules-test/Zefiros-Software/zpm/0.0.2", 
   1             version = "0.0.2"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/0.0.1/zpm",
   1             path = "modules-test/Zefiros-Software/zpm/0.0.1",
   1             version = "0.0.1"
             }
   1     } ) 
         
         -- cleanup
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesTags_HeadIgnored()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head", 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm2/2.0.0",
             
   1         "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1         "modules-test/Zefiros-Softwarefe/df/0.3.1", 
             "modules-test/Zefiros-Softwarefe/df/3.4.0"
   1     }
         
  11     for _, dir in ipairs( dirs ) do
                         
  10         u.assertFalse( os.isdir( dir ) )
  10         assert( os.mkdir( dir ) )
  10         u.assertTrue( os.isdir( dir ) )
             
  10         local file = io.open( dir .. "/init.lua", "w" )
  10         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesTags()
   1     u.assertEquals( #tags, 9 )
   2     u.assertItemsEquals( tags, {			
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/3.4.0/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/3.4.0",
   1             version = "3.4.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/1.5.4-ga/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1             version = "1.5.4-ga"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/0.3.1/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/0.3.1", 
   1             version = "0.3.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm2/2.0.0/init",
   1             path = "modules-test/Zefiros-Software/zpm2/2.0.0",
   1             version = "2.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm2/1.0.0-beta/init",
   1             path = "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1             version = "1.0.0-beta"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm2/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1             version = "0.0.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/3.0.0/init",
   1             path = "modules-test/Zefiros-Software/zpm/3.0.0",
   1             version = "3.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/1.0.0-alpha/init",
   1             path = "modules-test/Zefiros-Software/zpm/1.0.0-alpha",
   1             version = "1.0.0-alpha"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/zpm/0.0.1",
   1             version = "0.0.1"
             }
   1     } ) 
         
         -- cleanup
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesTags_Mixed()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm2/2.0.0",
             
   1         "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1         "modules-test/Zefiros-Softwarefe/df/0.3.1", 
             "modules-test/Zefiros-Softwarefe/df/3.4.0"
   1     }
         
  11     for i, dir in ipairs( dirs ) do
             
  10         u.assertFalse( os.isdir( dir ) )			
  10         assert( os.mkdir( dir ) )
  10         u.assertTrue( os.isdir( dir ) )
             
  10         if i ~= 1 then
   9             local file = io.open( dir .. "/init.lua", "w" )
   9             file:close()
             end
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesTags()
   1     u.assertEquals( #tags, 9 )
   2     u.assertItemsEquals( tags, {			
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/3.4.0/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/3.4.0",
   1             version = "3.4.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/1.5.4-ga/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1             version = "1.5.4-ga"
   1         },
             {
   1             loader = "modules-test/Zefiros-Softwarefe/df/0.3.1/init",
   1             path = "modules-test/Zefiros-Softwarefe/df/0.3.1", 
   1             version = "0.3.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm2/2.0.0/init",
   1             path = "modules-test/Zefiros-Software/zpm2/2.0.0",
   1             version = "2.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm2/1.0.0-beta/init",
   1             path = "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1             version = "1.0.0-beta"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm2/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1             version = "0.0.1"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/3.0.0/init",
   1             path = "modules-test/Zefiros-Software/zpm/3.0.0",
   1             version = "3.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/1.0.0-alpha/init",
   1             path = "modules-test/Zefiros-Software/zpm/1.0.0-alpha",
   1             version = "1.0.0-alpha"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/zpm/0.0.1",
   1             version = "0.0.1"
             }
   1     } ) 
         
         -- cleanup
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesTags_MatchVendor()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head", 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm2/2.0.0",
             
   1         "modules-test/Zefiros_Softwarefe/df/1.5.4-ga", 
   1         "modules-test/Zefiros_Softwarefe/df/0.3.1", 
             "modules-test/Zefiros_Softwarefe/df/3.4.0"
   1     }
         
  11     for _, dir in ipairs( dirs ) do
                         
  10         u.assertFalse( os.isdir( dir ) )
  10         assert( os.mkdir( dir ) )
  10         u.assertTrue( os.isdir( dir ) )
             
  10         local file = io.open( dir .. "/init.lua", "w" )
  10         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesTags( "Zefiros_Softwarefe" )
   1     u.assertEquals( #tags, 3 )
   2     u.assertItemsEquals( tags, {			
             {
   1             loader = "modules-test/Zefiros_Softwarefe/df/3.4.0/init",
   1             path = "modules-test/Zefiros_Softwarefe/df/3.4.0",
   1             version = "3.4.0"
   1         },
             {
   1             loader = "modules-test/Zefiros_Softwarefe/df/1.5.4-ga/init",
   1             path = "modules-test/Zefiros_Softwarefe/df/1.5.4-ga", 
   1             version = "1.5.4-ga"
   1         },
             {
   1             loader = "modules-test/Zefiros_Softwarefe/df/0.3.1/init",
   1             path = "modules-test/Zefiros_Softwarefe/df/0.3.1", 
   1             version = "0.3.1"
             }
   1     } ) 
         
         -- cleanup
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesTags_MatchModule()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head", 
   1         "modules-test/Zefiros-Software/zpm/1.0.0-alpha", 
   1         "modules-test/Zefiros-Software/zpm/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm/3.0.0",
             
   1         "modules-test/Zefiros-Software/zpm2/1.0.0-beta", 
   1         "modules-test/Zefiros-Software/zpm2/0.0.1", 
   1         "modules-test/Zefiros-Software/zpm2/2.0.0",
             
   1         "modules-test/Zefiros-Softwarefe/df/1.5.4-ga", 
   1         "modules-test/Zefiros-Softwarefe/df/0.3.1", 
             "modules-test/Zefiros-Softwarefe/df/3.4.0"
   1     }
         
  11     for _, dir in ipairs( dirs ) do
             
  10         u.assertFalse( os.isdir( dir ) )
  10         assert( os.mkdir( dir ) )
  10         u.assertTrue( os.isdir( dir ) )
             
  10         local file = io.open( dir .. "/init.lua", "w" )
  10         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesTags( "*", "zpm" )
   1     u.assertEquals( #tags, 3 )
   2     u.assertItemsEquals( tags, {	
             {
   1             loader = "modules-test/Zefiros-Software/zpm/3.0.0/init",
   1             path = "modules-test/Zefiros-Software/zpm/3.0.0",
   1             version = "3.0.0"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/1.0.0-alpha/init",
   1             path = "modules-test/Zefiros-Software/zpm/1.0.0-alpha",
   1             version = "1.0.0-alpha"
   1         },
             {
   1             loader = "modules-test/Zefiros-Software/zpm/0.0.1/init",
   1             path = "modules-test/Zefiros-Software/zpm/0.0.1",
   1             version = "0.0.1"
             }
   1     } ) 
         
         -- cleanup
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end
         

   2 function TestBootstrap:testListModulesHead_NoInit()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head",	
   1         "modules-test/Zefiros-Software/zpm2/head",	
             "modules-test/Zefiros-Softwarefe/df/head" 
   1     }
         
   4     for _, dir in ipairs( dirs ) do
             
   3         u.assertFalse( os.isdir( dir ) )
   3         assert( os.mkdir( dir ) )
   3         u.assertTrue( os.isdir( dir ) )
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesHead()
   1     u.assertEquals( #tags, 0 )
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end	

   2 function TestBootstrap:testListModulesHead_Init()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head",	
   1         "modules-test/Zefiros-Software/zpm2/head",	
             "modules-test/Zefiros-Softwarefe/df/head" 
   1     }
         
   4     for _, dir in ipairs( dirs ) do
             
   3         u.assertFalse( os.isdir( dir ) )
   3         assert( os.mkdir( dir ) )
   3         u.assertTrue( os.isdir( dir ) )
             
   3         local file = io.open( dir .. "/init.lua", "w" )
   3         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesHead()
   1     u.assertEquals( #tags, 3 )
   2     u.assertItemsEquals( tags, {
   1         "modules-test/Zefiros-Software/zpm/head/init",
   1         "modules-test/Zefiros-Software/zpm2/head/init",
             "modules-test/Zefiros-Softwarefe/df/head/init"
   1     } ) 
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesHead_InitModule()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head",	
   1         "modules-test/Zefiros/zpm/head",	
             "modules-test/Zefiros-Softwarefe/zpm/head" 
   1     }
         
   4     for _, dir in ipairs( dirs ) do
             
   3         u.assertFalse( os.isdir( dir ) )
   3         assert( os.mkdir( dir ) )
   3         u.assertTrue( os.isdir( dir ) )
             
   3         local file = io.open( dir .. "/zpm.lua", "w" )
   3         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesHead()
   1     u.assertEquals( #tags, 3 )
   2     u.assertItemsEquals( tags, {
   1         "modules-test/Zefiros-Software/zpm/head/zpm",
   1         "modules-test/Zefiros/zpm/head/zpm",
             "modules-test/Zefiros-Softwarefe/zpm/head/zpm"
   1     } ) 
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesHead_VersionIgnored()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head",	
   1         "modules-test/Zefiros/zpm/head",	
   1         "modules-test/Zefiros-Softwarefe/zpm/head",	
             "modules-test/Zefiros-Softwareffe/zpm/0.0.1" 
   1     }
         
   5     for _, dir in ipairs( dirs ) do
             
   4         u.assertFalse( os.isdir( dir ) )
   4         assert( os.mkdir( dir ) )
   4         u.assertTrue( os.isdir( dir ) )
             
   4         local file = io.open( dir .. "/zpm.lua", "w" )
   4         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesHead()
   1     u.assertEquals( #tags, 3 )
   2     u.assertItemsEquals( tags, {
   1         "modules-test/Zefiros-Software/zpm/head/zpm",
   1         "modules-test/Zefiros/zpm/head/zpm",
             "modules-test/Zefiros-Softwarefe/zpm/head/zpm"
   1     } ) 
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testListModulesHead_MatchVendor()

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dirs = { 
   1         "modules-test/Zefiros-Software/zpm/head",	
   1         "modules-test/Zefiros/zpm/head",	
             "modules-test/Zefiros_Softwarefe/zpm/head"
   1     }
         
   4     for _, dir in ipairs( dirs ) do
             
   3         u.assertFalse( os.isdir( dir ) )
   3         assert( os.mkdir( dir ) )
   3         u.assertTrue( os.isdir( dir ) )
             
   3         local file = io.open( dir .. "/zpm.lua", "w" )
   3         file:close()
         end
         
         -- test
         
   1     local tags = bootstrap.listModulesHead()
   1     u.assertEquals( #tags, 3 )
   2     u.assertItemsEquals( tags, {
   1         "modules-test/Zefiros-Software/zpm/head/zpm",
   1         "modules-test/Zefiros/zpm/head/zpm",
             "modules-test/Zefiros_Softwarefe/zpm/head/zpm"
   1     } ) 
   1     os.rmdir( "modules-test" )
         
   1     u.assertFalse( os.isdir( "modules-test" ) ) 
   1     bootstrap._dirModules = dirMods

     end

   2 function TestBootstrap:testCheckVersion_Basic()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "0.5.0", ">0.4.0" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.5.0", ">0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Multiple()
         
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "0.5.0", "<=0.0.0 || >0.4.0" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.5.0", "<=0.0.0 || >0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Fix()
         
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "0.5", "<=0.0.0 || >0.4.0" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.5", "<=0.0.0 || >0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Trim()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "0.5.0", "<=0.0.0  ||   >0.4.0" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.5.0", "<=0.0.0  ||   >0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Tripple()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "0.5.0", "<=0.0.0  ||>1.0.0  ||   >0.4.0" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.5.0", "<=0.0.0  ||>1.0.0  ||   >0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Head()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "@head", "@head" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "@head", "<=0.0.0  ||>1.0.0  ||@head" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.2.0", "<=0.0.0  ||>1.0.0  ||@head" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "@head", "<=0.0.0  ||>1.0.0  ||   >0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Branch()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "@dev", "@dev" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "@dev", "<=0.0.0  ||>1.0.0  ||@dev" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "0.2.0", "<=0.0.0  ||>1.0.0  ||@dev" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "@dev", "<=0.0.0  ||>1.0.0  ||   >0.5.0" ) )

     end

   2 function TestBootstrap:testCheckVersion_Wildcard()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "*", "<=0.0.0 || >0.4.0" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "*", "<=0.0.0 || >0.5.0" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "0.2.0", "<=0.0.0 || *" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "*", "@head" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "@head", ">0.5.0 *" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "@head", ">0.5.0 || *" ) )

     end

   2 function TestBootstrap:testCheckVersion_Caret()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "1.2.3", "^1.2.3" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "1.2.2", "^1.2.3" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "2.0.0", "^1.2.3" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "2.0.0", "^1.2.3 || 2.0.0" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "1.2.4", "^1.2.3" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "1.3.4", "^1.2.3" ) )

     end

   2 function TestBootstrap:testCheckVersion_Tilde()

   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "1.2.3", "~1.2.3" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "1.2.2", "~1.2.3" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "2.0.0", "~1.2.3" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "2.0.0", "~1.2.3 || 2.0.0" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "1.2.4", "~1.2.3" ) )
   1     u.assertFalse( bootstrap.checkVersion( premake.checkVersion, "1.3.4", "~1.2.3" ) )
   1     u.assertTrue( bootstrap.checkVersion( premake.checkVersion, "1.2.5", "~1.2.3" ) )

     end

   2 function TestBootstrap:testFixVersion_Basic()

   1     u.assertEquals( bootstrap.fixVersion( "0.5" ), "0.5.0" )	
   1     u.assertEquals( bootstrap.fixVersion( "5" ), "5.0.0" )	
   1     u.assertEquals( bootstrap.fixVersion( "0.5.1" ), "0.5.1" )
   1     u.assertEquals( bootstrap.fixVersion( "0.5.1.2" ), "0.5.1.2" )

     end

   2 function TestBootstrap:testRequireOld()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
         
             
   1     local file = io.open( bootstrap._dirModules .. "/testRequireOld.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsOld( require, bootstrap._dirModules .. "/testRequireOld" )
         
         -- test
   1     u.assertEquals( mo, "bar" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireOld_Remember()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
   1     u.assertFalse( os.isfile( bootstrap._dirModules .. "/testRequireOld.lua" ) )
         
   1     local mo = bootstrap.requireVersionsOld( require, bootstrap._dirModules .. "/testRequireOld" )
         
         -- test
   1     u.assertEquals( mo, "bar" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireOld_Remember2()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
                     
   1     local file = io.open( bootstrap._dirModules .. "/testRequireOld.lua", "w" )
   2     file:write([[
             return "barf"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsOld( require, bootstrap._dirModules .. "/testRequireOld" )
         
         -- test
   1     u.assertEquals( mo, "bar" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireOld_LuaRockStyle()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
             
   1     local file = io.open( bootstrap._dirModules .. "/testRequireOld_LuaRockStyle.lua", "w" )
   2     file:write([[
             return require( "testRequireOld_LuaRockStyle.bar" )
   1     ]])
   1     file:close()
         
             
   1     file2 = io.open( bootstrap._dirModules .. "/testRequireOld_LuaRockStyle/bar.lua", "w" )
   2     file2:write([[
             return require( "testRequireOld_LuaRockStyle.bar2" )
   1     ]])
   1     file2:close()
         
             
   1     file3 = io.open( bootstrap._dirModules .. "/testRequireOld_LuaRockStyle/bar2.lua", "w" )
   2     file3:write([[
             return "bar2"
   1     ]])
   1     file3:close()
         
   1     local mo = bootstrap.requireVersionsOld( require, bootstrap._dirModules .. "/testRequireOld_LuaRockStyle" )
         
         -- test
   1     u.assertEquals( mo, "bar2" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireOld_NoFile()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
   1     u.assertFalse( os.isfile( bootstrap._dirModules .. "/foo3.lua" ) )
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
         
   1     u.assertErrorMsgContains( "module './modules-test/foo3' not found", bootstrap.requireVersionsOld, require, bootstrap._dirModules .. "/foo3" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireOld_Fail()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
         
             
   1     local file = io.open( bootstrap._dirModules .. "/foo4.lua", "w" )
   2     file:write([[
             return "barf
   1     ]])
   1     file:close()
         
   1     u.assertErrorMsgContains( "unfinished string near '\"barf'", bootstrap.requireVersionsOld, require, bootstrap._dirModules .. "/foo4" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end






   2 function TestBootstrap:testRequireVersionHead()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/zpm/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/zpm.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "zpm"} )
         
         -- test
   1     u.assertEquals( mo, "bar" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end	

   2 function TestBootstrap:testRequireVersionHead_Underscore()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/zpm_/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/zpm_.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "zpm_"} )
         
         -- test
   1     u.assertEquals( mo, "bar" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireVersionHead_Dash()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/zpm-/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/zpm-.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "zpm-"} )
         
         -- test
   1     u.assertEquals( mo, "bar" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireVersionHead_CWD()
         
   1     local oldPath = package.path
         
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "."
   1     local dir = "Zefiros-Software/testRequireVersionHead_CWD/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
                     
   1     local file = io.open( dir .. "/testRequireVersionHead_CWD.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "testRequireVersionHead_CWD"} )
         
         -- test
   1     u.assertEquals( mo, "bar" )
   1     u.assertTrue( found )
         
   1     os.rmdir( "Zefiros-Software" )
         
   1     u.assertFalse( os.isdir( dir ) )

   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireVersionHead_Multiple()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_Multiple/head"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_Multiple2/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )
                     
   1     local file = io.open( dir .. "/testRequireVersionHead_Multiple.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
                     
   1     file2 = io.open( dir2 .. "/testRequireVersionHead_Multiple2.lua", "w" )
   2     file2:write([[
             return "bar2"
   1     ]])
   1     file2:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "bar" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) )
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionHead_Multiple2()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_Multiple3/head"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_Multiple4/head"
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
                     
   1     file2 = io.open( dir2 .. "/testRequireVersionHead_Multiple4.lua", "w" )
   2     file2:write([[
             return "bar2"
   1     ]])
   1     file2:close()
                     
   1     local file = io.open( dir .. "/testRequireVersionHead_Multiple3.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "bar" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) )
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireVersionHead_Remember()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_Remember/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
   1     u.assertFalse( os.isfile( dir .. "/zpm.lua" ) )
         
   1     u.assertErrorMsgContains( "Module with vendor 'Zefiros-Software' and name 'testRequireVersionHead_Remember' not found", bootstrap.requireVersionHead, require, {"Zefiros-Software", "testRequireVersionHead_Remember"} )
                 
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end	

   2 function TestBootstrap:testRequireVersionHead_LuaRockStyle()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_LuaRockStyle/head"
             
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
             
   1     local file = io.open( dir .. "/testRequireVersionHead_LuaRockStyle.lua", "w" )
   2     file:write([[
             return require( "testRequireVersionHead_LuaRockStyle.bar" )
   1     ]])
   1     file:close()
         
             
   1     file2 = io.open( dir .. "/testRequireVersionHead_LuaRockStyle/bar.lua", "w" )
   2     file2:write([[
             return require( "testRequireVersionHead_LuaRockStyle.bar2" )
   1     ]])
   1     file2:close()
         
             
   1     file3 = io.open( dir .. "/testRequireVersionHead_LuaRockStyle/bar2.lua", "w" )
   2     file3:write([[
             return "barsss2"
   1     ]])
   1     file3:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "testRequireVersionHead_LuaRockStyle"} )
         
         -- test
   1     u.assertEquals( mo, "barsss2" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionHead_LuaRockStyle_Absolute()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = path.join( os.getcwd(), "modules-test" )
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_LuaRockStyle_Absolute/head"
             
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
             
   1     local file = io.open( dir .. "/testRequireVersionHead_LuaRockStyle_Absolute.lua", "w" )
   2     file:write([[
             return require( "testRequireVersionHead_LuaRockStyle_Absolute.bar" )
   1     ]])
   1     file:close()
         
             
   1     file2 = io.open( dir .. "/testRequireVersionHead_LuaRockStyle_Absolute/bar.lua", "w" )
   2     file2:write([[
             return require( "testRequireVersionHead_LuaRockStyle_Absolute.bar2" )
   1     ]])
   1     file2:close()
         
             
   1     file3 = io.open( dir .. "/testRequireVersionHead_LuaRockStyle_Absolute/bar2.lua", "w" )
   2     file3:write([[
             return "barsss2"
   1     ]])
   1     file3:close()
         
   1     local mo, found = bootstrap.requireVersionHead( require, {"Zefiros-Software", "testRequireVersionHead_LuaRockStyle_Absolute"} )
         
         -- test
   1     u.assertEquals( mo, "barsss2" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end


   2 function TestBootstrap:testRequireVersionHead_NoFile()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionHead_NoFile/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
   1     u.assertFalse( os.isfile( dir .. "/testRequireVersionHead_NoFile.lua" ) )
         
   1     u.assertErrorMsgContains( "Module with vendor 'Zefiros-Software' and name 'testRequireVersionHead_NoFile' not found", bootstrap.requireVersionHead, require, {"Zefiros-Software", "testRequireVersionHead_NoFile"} )
                 
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end	



   2 function TestBootstrap:testRequireVersionHead_Fail()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros_Software/testRequireVersionHead_Fail/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionHead_Fail.lua", "w" )
   2     file:write([[
             return "bar
   1     ]])
   1     file:close()
         
   1     u.assertErrorMsgContains( "unfinished string near '\"bar'", bootstrap.requireVersionHead, require, {"Zefiros_Software", "testRequireVersionHead_Fail"} )
             
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end



   2 function TestBootstrap:testRequireVersionsNew()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew.lua", "w" )
   2     file:write([[
             return "testRequireVersionsNew"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew"} )
         
         -- test
   1     u.assertEquals( mo, "testRequireVersionsNew" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Underscore()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-testf"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Underscore/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_Underscore.lua", "w" )
   2     file:write([[
             return "testRequireVersionsNew_Underscore"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew_Underscore"} )
         
         -- test
   1     u.assertEquals( mo, "testRequireVersionsNew_Underscore" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Dash()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-testf"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew-Dash/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew-Dash.lua", "w" )
   2     file:write([[
             return "testRequireVersionsNew_Dash"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew-Dash"} )
         
         -- test
   1     u.assertEquals( mo, "testRequireVersionsNew_Dash" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_CWD()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./"
         
   1     local dir = "./Zefiros_Software/testRequireVersionsNew_CWD/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_CWD.lua", "w" )
   2     file:write([[
             return "testRequireVersionsNew_CWD"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros_Software", "testRequireVersionsNew_CWD"} )
         
         -- test
   1     u.assertEquals( mo, "testRequireVersionsNew_CWD" )
         
   1     os.rmdir( "./Zefiros_Software" )		
         
   1     u.assertFalse( os.isdir( "./Zefiros_Software" ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/atestRequireVersionsNew_Multiple/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()		
             
   1     local file2 = io.open( dir2 .. "/atestRequireVersionsNew_Multiple.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "barrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple2()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/atestRequireVersionsNew_Multiple2/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/ztestRequireVersionsNew_Multiple2/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )		
             
   1     local file2 = io.open( dir2 .. "/ztestRequireVersionsNew_Multiple2.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
                     
   1     local file = io.open( dir .. "/atestRequireVersionsNew_Multiple2.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "barrr" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Version()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Version/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/atestRequireVersionsNew_Multiple_Version/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple_Version.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()		
             
   1     local file2 = io.open( dir2 .. "/atestRequireVersionsNew_Multiple_Version.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"}, ">0.1.0" )
         
         -- test
   1     u.assertEquals( mo, "barrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Same()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple_Same.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()	
             
   1     local file2 = io.open( dir2 .. "/testRequireVersionsNew_Multiple_Same.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "barrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Same2()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same2/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same2/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
             
   1     local file2 = io.open( dir2 .. "/testRequireVersionsNew_Multiple_Same2.lua", "w" )
   2     file2:write([[
             return "barrrrrrf"
   1     ]])
   1     file2:close()
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple_Same2.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()	
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "barrrrrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Same_Version()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same_Version/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same_Version/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple_Same_Version.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()	
             
   1     local file2 = io.open( dir2 .. "/testRequireVersionsNew_Multiple_Same_Version.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"}, "^0.1.0" )
         
         -- test
   1     u.assertEquals( mo, "barrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Same_Filter()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/versionsNew_Multiple_Same_Filter/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/versionsNew_Multiple_Same_Filter/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
                     
   1     local file = io.open( dir .. "/versionsNew_Multiple_Same_Filter.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()	
             
   1     local file2 = io.open( dir2 .. "/versionsNew_Multiple_Same_Filter.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"} )
         
         -- test
   1     u.assertEquals( mo, "barrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Filter_Same2()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Filter_Same2/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Filter_Same2/0.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
             
   1     local file2 = io.open( dir2 .. "/testRequireVersionsNew_Multiple_Filter_Same2.lua", "w" )
   2     file2:write([[
             return "barrrf"
   1     ]])
   1     file2:close()
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple_Filter_Same2.lua", "w" )
   2     file:write([[
             return "barrr"
   1     ]])
   1     file:close()	
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew_Multiple_Filter_Same2"} )
         
         -- test
   1     u.assertEquals( mo, "barrrf" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Multiple_Same_Filter_Version()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same_Filter_Version/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Multiple_Same_Filter_Version/1.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_Multiple_Same_Filter_Version.lua", "w" )
   2     file:write([[
             return "barrrf"
   1     ]])
   1     file:close()	
             
   1     local file2 = io.open( dir2 .. "/testRequireVersionsNew_Multiple_Same_Filter_Version.lua", "w" )
   2     file2:write([[
             return "barrr"
   1     ]])
   1     file2:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "*"}, ">0.1" )
         
         -- test
   1     u.assertEquals( mo, "barrr" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_NoValidVersion()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_NoValidVersion/0.0.1"
   1     local dir2 = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_NoValidVersion/1.1.1-alpha"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
   1     assert( os.mkdir( dir2 ) )
   1     u.assertTrue( os.isdir( dir2 ) )	
                     
   1     local file = io.open( dir .. "/testRequireVersionsNew_NoValidVersion.lua", "w" )
   2     file:write([[
             return "barrrf"
   1     ]])
   1     file:close()	
             
   1     local file2 = io.open( dir2 .. "/testRequireVersionsNew_NoValidVersion.lua", "w" )
   2     file2:write([[
             return "barrr"
   1     ]])
   1     file2:close()
         
   1     u.assertErrorMsgContains( "Module with vendor 'Zefiros-Software' and name '*' has no releases satisfying version '>2'!", bootstrap.requireVersionsNew, require, {"Zefiros-Software", "*"}, ">2" )
         
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Remember()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
   1     u.assertFalse( os.isfile( dir .. "/testRequireVersionsNew.lua" ) )
         
   1     u.assertErrorMsgContains( "Module with vendor 'Zefiros-Software' and name 'testRequireVersionsNew' not found", bootstrap.requireVersionsNew, require, {"Zefiros-Software", "testRequireVersionsNew"} )
                 
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Remember2()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
             
   1     local file = io.open( dir .. "/testRequireVersionsNew.lua", "w" )
   2     file:write([[
             return "fee"
   1     ]])
   1     file:close()
         
   1     local mod = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew"} )
                 
         -- test
   1     u.assertEquals( mo, nil )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end
             
   2 function TestBootstrap:testRequireVersionsNew_LuaRockStyle()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_LuaRockStyle/0.0.5"
             
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_LuaRockStyle.lua", "w" )
   2     file:write([[
             return require( "testRequireVersionsNew_LuaRockStyle.bar" )
   1     ]])
   1     file:close()
         
             
   1     file2 = io.open( dir .. "/testRequireVersionsNew_LuaRockStyle/bar.lua", "w" )
   2     file2:write([[
             return require( "testRequireVersionsNew_LuaRockStyle.bar2" )
   1     ]])
   1     file2:close()
         
             
   1     file3 = io.open( dir .. "/testRequireVersionsNew_LuaRockStyle/bar2.lua", "w" )
   2     file3:write([[
             return "barsss2"
   1     ]])
   1     file3:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew_LuaRockStyle"} )
         
         -- test
   1     u.assertEquals( mo, "barsss2" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end
             
   2 function TestBootstrap:testRequireVersionsNew_LuaRockStyle_Absolute()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = path.join( os.getcwd(), "modules-test" )
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_LuaRockStyle/0.0.5"
             
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_LuaRockStyle.lua", "w" )
   2     file:write([[
             return require( "testRequireVersionsNew_LuaRockStyle.bar" )
   1     ]])
   1     file:close()
         
             
   1     file2 = io.open( dir .. "/testRequireVersionsNew_LuaRockStyle/bar.lua", "w" )
   2     file2:write([[
             return require( "testRequireVersionsNew_LuaRockStyle.bar2" )
   1     ]])
   1     file2:close()
         
             
   1     file3 = io.open( dir .. "/testRequireVersionsNew_LuaRockStyle/bar2.lua", "w" )
   2     file3:write([[
             return "barsss2"
   1     ]])
   1     file3:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew_LuaRockStyle"} )
         
         -- test
   1     u.assertEquals( mo, "barsss2" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end


   2 function TestBootstrap:testRequireVersionsNew_Head()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Head/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_Head.lua", "w" )
   2     file:write([[
             return "baree"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersionsNew( require, {"Zefiros-Software", "testRequireVersionsNew_Head"} )
         
         -- test
   1     u.assertEquals( mo, "baree" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end	


   2 function TestBootstrap:testRequireVersionsNew_NoFile()

   1     local oldPath = package.path
         
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_NoFile/0.2.0"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
   1     u.assertFalse( os.isfile( dir .. "/testRequireVersionsNew_NoFile.lua" ) )
   1     u.assertFalse( os.isfile( dir .. "../head/testRequireVersionsNew_NoFile.lua" ) )
         
   1     u.assertErrorMsgContains( "Module with vendor 'Zefiros-Software' and name 'testRequireVersionHead_NoFile' not found", bootstrap.requireVersionHead, require, {"Zefiros-Software", "testRequireVersionHead_NoFile"} )
                 
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end	

   2 function TestBootstrap:testRequireVersionsNew_Fail()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Fail/0.0.1"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_Fail.lua", "w" )
   2     file:write([[
             return "bar
   1     ]])
   1     file:close()
         
   1     u.assertErrorMsgContains( "unfinished string near '\"bar'", bootstrap.requireVersionsNew, require, {"Zefiros-Software", "testRequireVersionsNew_Fail"} )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end

   2 function TestBootstrap:testRequireVersionsNew_Fail_Head()

   1     local oldPath = package.path

         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersionsNew_Fail_Head/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersionsNew_Fail_Head.lua", "w" )
   2     file:write([[
             return "bar
   1     ]])
   1     file:close()
         
   1     u.assertErrorMsgContains( "unfinished string near '\"bar'", bootstrap.requireVersionsNew, require, {"Zefiros-Software", "testRequireVersionsNew_Fail_Head"} )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )

     end




   2 function TestBootstrap:testRequireVersions()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
             
   1     assert( os.mkdir( bootstrap._dirModules ) )
   1     u.assertTrue( os.isdir( bootstrap._dirModules ) )
         
             
   1     local file = io.open( bootstrap._dirModules .. "/testRequireVersions.lua", "w" )
   2     file:write([[
             return "testRequireVersions"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersions( require, bootstrap._dirModules .. "/testRequireVersions" )
         
         -- test
   1     u.assertEquals( mo, "testRequireVersions" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods

         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireVersions_Head()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersions_Head/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )		
             
   1     local file = io.open( dir .. "/testRequireVersions_Head.lua", "w" )
   2     file:write([[
             return "testRequireVersions_Head"
   1     ]])
   1     file:close()
         
   1     local mo, found = bootstrap.requireVersions( require, "Zefiros-Software/testRequireVersions_Head", "@head" )
         
         -- test
   1     u.assertEquals( mo, "testRequireVersions_Head" )
   1     u.assertTrue( found )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end	

   2 function TestBootstrap:testRequireVersions_Head_Fallback()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersions_Head_Fallback/head"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersions_Head_Fallback.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersions( require, "Zefiros-Software/testRequireVersions_Head_Fallback" )
         
         -- test
   1     u.assertEquals( mo, "bar" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end

   2 function TestBootstrap:testRequireVersions_Version()

***0     local oldPath = package.path
         -- init
***0     local dirMods = bootstrap._dirModules
***0     bootstrap._dirModules = "./modules-test"
         
***0     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersions_Version/0.2.3"
         
***0     assert( os.mkdir( dir ) )
***0     u.assertTrue( os.isdir( dir ) )
         
             
***0     local file = io.open( dir .. "/testRequireVersions_Version.lua", "w" )
***0     file:write([[
             return "bar"
***0     ]])
***0     file:close()
         
***0     local mo = bootstrap.requireVersions( require, "Zefiros-Software/testRequireVersions_Version" )
         
         -- test
***0     u.assertEquals( mo, "bar" )
         
***0     os.rmdir( bootstrap._dirModules )
         
***0     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
***0     bootstrap._dirModules = dirMods


         -- path correctly restored
***0     u.assertEquals( package.path, oldPath )
     end	

   2 function TestBootstrap:testRequireVersions_Version()

   1     local oldPath = package.path
         -- init
   1     local dirMods = bootstrap._dirModules
   1     bootstrap._dirModules = "./modules-test"
         
   1     local dir = bootstrap._dirModules .. "/Zefiros-Software/testRequireVersions_Version/0.2.3"
         
   1     assert( os.mkdir( dir ) )
   1     u.assertTrue( os.isdir( dir ) )
         
             
   1     local file = io.open( dir .. "/testRequireVersions_Version.lua", "w" )
   2     file:write([[
             return "bar"
   1     ]])
   1     file:close()
         
   1     local mo = bootstrap.requireVersions( require, "Zefiros-Software/testRequireVersions_Version" )
         
         -- test
   1     u.assertEquals( mo, "bar" )
         
   1     os.rmdir( bootstrap._dirModules )
         
   1     u.assertFalse( os.isdir( bootstrap._dirModules ) ) 
   1     bootstrap._dirModules = dirMods


         -- path correctly restored
   1     u.assertEquals( package.path, oldPath )
     end	



   2 function TestBootstrap:testzRequireVersionsFromDirectories()

   1     local dirs = bootstrap.directories
   1     bootstrap.directories = { "a", "b", "c" }
   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     bootstrap.requireVersions = function()
   3         its = its + 1
             
   3         if its == 1 then
   1             u.assertEquals( bootstrap._dirModules, "a" )
   1             error( "next" )
             
***0             return "fault"
   2         elseif its == 2 then
   1             u.assertEquals( bootstrap._dirModules, "b" )
   1             error( "next" )
             
***0             return "fault"
   1         elseif its == 3 then
   1             u.assertEquals( bootstrap._dirModules, "c" )
             
   1             return "correct"
             else
***0             assert( false, "This should not happen!" )
             end
             
***0         return "brrrr"
         end
         
   1     local mod = bootstrap.requireVersionsFromDirectories( nil, "testzRequireVersionsFromDirectories", nil )
         
   1     u.assertEquals( mod, "correct" )	
   1     u.assertEquals( its, 3 )	
         
   1     bootstrap.requireVersions = requireVersions
   1     bootstrap.directories = dirs
     end	
         
   2 function TestBootstrap:testzRequireVersionsFromDirectories_2()

   1     local dirs = bootstrap.directories
   1     bootstrap.directories = { "a", "b", "c" }
   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     bootstrap.requireVersions = function()
   2         its = its + 1
             
   2         if its == 1 then
   1             u.assertEquals( bootstrap._dirModules, "a" )
   1             error( "next" )
             
***0             return "fault"
   1         elseif its == 2 then
   1             u.assertEquals( bootstrap._dirModules, "b" )
             
   1             return "correct"
***0         elseif its == 3 then
***0             u.assertEquals( bootstrap._dirModules, "c" )			
***0             error( "next" )
                 
***0             return "fault"
             else
***0             assert( false, "This should not happen!" )
             end
             
***0         return "brrrr"
         end
         
   1     local mod = bootstrap.requireVersionsFromDirectories( nil, "testzRequireVersionsFromDirectories_2", nil )
         
   1     u.assertEquals( mod, "correct" )	
   1     u.assertEquals( its, 2 )	
         
   1     bootstrap.requireVersions = requireVersions
   1     bootstrap.directories = dirs
     end	
         
   2 function TestBootstrap:testzRequireVersionsFromDirectories_3()

   1     local dirs = bootstrap.directories
   1     bootstrap.directories = { "a", "b", "c" }
   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     bootstrap.requireVersions = function()
   3         its = its + 1
             
   3         if its == 1 then
   1             u.assertEquals( bootstrap._dirModules, "a" )
   1             error( "next" )
             
***0             return "fault"
   2         elseif its == 2 then
   1             u.assertEquals( bootstrap._dirModules, "b" )
   1             error( "next" )
             
***0             return "fault"
   1         elseif its == 3 then
   1             u.assertEquals( bootstrap._dirModules, "c" )	
                 
   1             return "correct"
             else
***0             assert( false, "This should not happen!" )
             end
             
***0         return "brrrr"
         end
         
   1     local mod = bootstrap.requireVersionsFromDirectories( nil, "testzRequireVersionsFromDirectories_3", nil )
         
   1     u.assertEquals( mod, "correct" )	
   1     u.assertEquals( its, 3 )	
         
   1     bootstrap.requireVersions = requireVersions
   1     bootstrap.directories = dirs
     end
         
   2 function TestBootstrap:testzRequireVersionsFromDirectories_None()

   1     local dirs = bootstrap.directories
   1     bootstrap.directories = { "a", "b", "c" }
   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     bootstrap.requireVersions = function()
   3         its = its + 1
             
   3         if its == 1 then
   1             u.assertEquals( bootstrap._dirModules, "a" )
   1             error( "next1" )
             
***0             return "fault"
   2         elseif its == 2 then
   1             u.assertEquals( bootstrap._dirModules, "b" )
   1             error( "next2" )
             
***0             return "fault"
   1         elseif its == 3 then
   1             u.assertEquals( bootstrap._dirModules, "c" )	
   1             error( "next3" )
                 
***0             return "fault"
             end
             
***0         return "brrrr"
         end
         
   1     u.assertErrorMsgContains( "next3", bootstrap.requireVersionsFromDirectories, nil, "testzRequireVersionsFromDirectories_3", nil )

   1     u.assertEquals( its, 3 )	
         
   1     bootstrap.requireVersions = requireVersions
   1     bootstrap.directories = dirs
     end	



   2 function TestBootstrap:testRequire()

   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     bootstrap.requireVersions = function()
   1         its = its + 1
   1         return "brrrr"
         end
         
   1     local mod = bootstrap.require( nil, "testRequire", nil )
         
   1     u.assertEquals( mod, "brrrr" )	
   1     u.assertEquals( its, 1 )	
         
   1     bootstrap.requireVersions = requireVersions
     end	



   2 function TestBootstrap:testRequire_Dirs()

   1     local requireVersionsFromDirectories = bootstrap.requireVersionsFromDirectories
   1     local its = 0
   1     bootstrap.requireVersionsFromDirectories = function()
   1         its = its + 1
   1         return "brrrr"
         end
         
   1     local mod = bootstrap.require( nil, "requireVersionsFromDirectories_Dirs", nil )
         
   1     u.assertEquals( mod, "brrrr" )	
   1     u.assertEquals( its, 1 )	
         
   1     bootstrap.requireVersionsFromDirectories = requireVersionsFromDirectories
     end	

   2 function TestBootstrap:testRequire_Memoisation()

   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     bootstrap.requireVersions = function()
   1         its = its + 1
   1         return "brrrr"
         end
         
   1     local mod = bootstrap.require( nil, "testRequire_Memoisation", nil )
         
   1     u.assertEquals( mod, "brrrr" )	
   1     u.assertEquals( its, 1 )	
         
   1     mod = bootstrap.require( nil, "testRequire_Memoisation", nil )
   1     u.assertEquals( mod, "brrrr" )	
   1     u.assertEquals( its, 1 )
         
   1     bootstrap.requireVersions = requireVersions
     end	

   2 function TestBootstrap:testRequire_onLoad()

   1     local requireVersions = bootstrap.requireVersions
   1     local its = 0
   1     local loaded = 0
   1     bootstrap.requireVersions = function()
   1         its = its + 1
   1         local ret = {}
   1         function ret:onLoad()
   1             loaded = loaded + 1
             end
   1         ret.value = "brrrr"
             
   1         return ret
         end
         
   1     local mod = bootstrap.require( nil, "testRequire_onLoad", nil )
         
   1     u.assertEquals( mod.value, "brrrr" )	
   1     u.assertEquals( its, 1 )	
   1     u.assertEquals( loaded, 1 )
         
   1     mod = bootstrap.require( nil, "testRequire_onLoad", nil )
   1     u.assertEquals( mod.value, "brrrr" )	
   1     u.assertEquals( its, 1 )
   1     u.assertEquals( loaded, 1 )
         
   1     bootstrap.requireVersions = requireVersions
     end	

==============================================================================
Summary
==============================================================================

File                                                 Hits Missed Coverage
-------------------------------------------------------------------------
C:/ProgramData/zpm/bootstrap/bootstrap.lua           207  24     89.61%
C:/ProgramData/zpm/bootstrap/semver.lua              88   20     81.48%
C:/ProgramData/zpm/bootstrap/test/action/test.lua    7    0      100.00%
C:/ProgramData/zpm/bootstrap/test/extern/luaunit.lua 622  603    50.78%
C:/ProgramData/zpm/bootstrap/test/tests.lua          1507 39     97.48%
-------------------------------------------------------------------------
Total                                                2431 686    77.99%
